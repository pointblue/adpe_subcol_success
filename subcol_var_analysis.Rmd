---
title: "Analysis of variation in reproductive success by subcolony"
author: "Annie Schmidt"
date: "June 2, 2016"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

```{r load libraries and data}
library(ggplot2)
library(dplyr)
library(tidyr)
library(readr)
library(mgcv)
library(bbmle)
# library(dismo)
# library(gbm)

#Set working directory
# setwd("Z:/Informatics/S031/analyses/aschmidt/subcol_var")

  
# Define functions #### 
# correlation matrix of data
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y, use="complete.obs"))
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * r)
}


# read in data files ####
# Crozier
c_ct_meas <- read.csv("data/croz_selected_meas_ct_all.csv")

# Royds
r_ct_meas <- read_csv("data/royds_selected_meas_ct_all.csv")


```

Format data for modeling
```{r format data, echo = FALSE}
# select columns for analysis
# create index of m subcolonies to hold out of analysis 
# have a disproportionate number from area M which is where most of the KA birds are
# so holding out some of the M subcolonies to predict to and correlate prediction with BQI would be good?

c_dat <- c_ct_meas%>%
  dplyr::select(col,season,area_name, subcol,active_ct,prod,area,perim,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_elev,mean_wind,mean_solar,flood_risk,skua50,skua100)%>%
  mutate(season=factor(season),subcol=factor(subcol))%>%
   #shift aspect values >300 to other side of 0
         #=ifelse(!is.na(mean_aspect)&mean_aspect>300,mean_aspect-360,mean_aspect), m_not=ifelse(area_name=="m","m","other"))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1415","1516","1617","1718"),!subcol=="s3",!prod=="NA"&!is.na(pa_ratio))%>%
  group_by(subcol)%>%
  mutate(growth=(active_ct/lag(active_ct)-1)*100)%>%
  ungroup()

# set levels for season to allow older seasons to be used
levels(c_dat$season)<-levels(factor(c_ct_meas$season))

# hold out data from random subcol and random years
set.seed(13)
hold_index <- sample(1:nrow(c_dat), 30,replace=FALSE)

c_dat_hold <- c_dat[hold_index,]
c_dat <- c_dat[-hold_index,]


hist(c_dat$growth)


# Scale values to make model fitting easier
c_dat_scale <- c_dat%>%
  #select(-col,-season,-area_name,-subcol,-mean_elev)%>%
  mutate_at(vars(active_ct,prod,area,perim,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_elev,mean_wind,mean_solar,flood_risk, adjust_mean_aspect),funs(scale))


# Format Royds data
r_dat <- r_ct_meas%>%
  dplyr::select(col,season,area_name, subcol,active_ct,prod,area,perim=perimeter,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev, mean_elev,mean_wind,mean_solar,flood_risk,skua50)%>%
  mutate(season=factor(season),subcol=factor(subcol),col=factor(col))%>%
  replace_na(list(flood_risk=0))%>%
  filter(!is.na(active_ct), !active_ct==0, !subcol=="1b")
# one slope value for Royds 1b seems off (unlikely it's a 50deg slope)
# crazy slope causes other variables to be off also, just going to remove 1b
# # Setting it to value from other overpalling pixel = Pixel value	25.368334
# r_dat$mean_slope[r_dat$subcol=="1b"]<- 25.37
# crazy slope causes other variables to be off also, just going to remove 1b

# Scale values to make model fitting easier
r_dat_scale<- r_dat%>%
  mutate(flood_riskperc=flood_risk/max(flood_risk,na.rm=TRUE))%>%
  mutate_at(vars(active_ct,prod,area,perim,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_elev,mean_wind,mean_solar),funs(scale))
  

sapply(r_dat,class)

pairs(c_dat_scale[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_wind", "mean_solar","flood_risk","skua50","skua100")],lower.panel = panel.smooth, upper.panel = panel.cor)

# c_dat$ln_flood[c_dat$ln_flood=="-Inf"]<-min(c_dat$ln_flood)

# Combine data
all_dat <- c_dat%>%
  full_join(r_dat)%>%
  mutate(subcol=as.factor(subcol), col=as.factor(col))

all_dat_scale <- all_dat%>%
  mutate(subcol=as.factor(subcol), col=as.factor(col),season=factor(season),flood_risk_trans=log1p(flood_risk),adjust_mean_aspect=log1p(mean_aspect),skua50_yn=factor(ifelse(skua50==1,"y","n")))%>%
  mutate_at(vars(active_ct,prod,area,perim,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_elev,mean_wind,mean_solar,flood_risk_trans, adjust_mean_aspect),funs(scale))

# melt data for data vis
subcol_attr <- all_dat_scale%>%
  select(-season,-active_ct,-prod,-growth,-area_name,-skua50,-skua100, -mean_elev, -perim, -adjust_mean_aspect)%>%
  group_by(col, subcol)%>%
  dplyr::slice(1)%>%
  gather(subcol_attr,value=measurement,-col,-subcol)

p<-ggplot(subcol_attr, aes(x=col, y=measurement,fill=subcol_attr))+
    geom_boxplot()
p +  facet_wrap(~subcol_attr,scales="free")+
    labs(x="subcol")

# plot with M counts compared to outside of M
m_cts <- c_ct_meas%>%
  select(season,area_name, subcol, prod)%>%
  mutate(season=factor(season))%>%
  filter(area_name=="m", season%in%c('1415','1516','1617','1718'))

c_dat 
ggplot(c_dat, aes(season,prod, fill=m_not))+
  geom_boxplot()

ggplot(c_dat, aes(m_not,prod))+
  geom_boxplot()

ggplot(c_dat, aes(area_name,prod))+
  geom_boxplot(fill="dodgerblue")

t.test(c_dat$prod[c_dat$m_not=="m"],c_dat$prod[!c_dat$m_not=="m"])
t.test(c_dat$prod[c_dat$area_name=="m"],c_dat$prod[c_dat$area_name=="qr"])
t.test(c_dat$prod[c_dat$area_name=="m"],c_dat$prod[c_dat$area_name=="l"])
t.test(c_dat$prod[c_dat$area_name=="qr"],c_dat$prod[c_dat$area_name=="l"])

# M time series plot
c_ct_meas<- c_ct_meas%>%
  mutate(season=factor(season), m_not=ifelse(area_name=="m","m","other"))
ggplot(c_ct_meas, aes(season,prod, fill=m_not))+
  geom_boxplot()

```

Trying GAMMs
```{r Trying GAMMs}
# Starting with model with all variables of interest subcol id as random effect
# using REML based on recommendation in Marra and Wood 2011
# # Except if I want to compare models with different fixed effects I shouldn't
# # https://stats.stackexchange.com/questions/116770/reml-or-ml-to-compare-two-mixed-effects-models-with-differing-fixed-effects-but?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
# # thread suggests using REML because it does a better job with random effects on just your final model for inference and prediction

#concurv_comb<- concurvity(gam_combined, full=FALSE)
# Remove variables with >0.6 estimated concurvity (??)
# # Not sure I should have aspect, wind, and solar in same model
# # Use model selection for this?

gam_c_global <- gam(prod~s(area)+s(pa_ratio)+s(mean_slope)+s(adjust_mean_aspect,k=10, bs="cc") +s(mean_solar) +s(mean_wind)+s(flood_risk_trans)+skua50+season+s(subcol,k=k, bs="re"), data=all_dat_scale[all_dat_scale$col=="croz",], select=TRUE, method="ML")
summary(gam_c_global)
anova(gam_c_global)
plot.gam(gam_c_global,pages=1, scale=0, shade=TRUE)
# can't fit this model with season interactions
gam.vcomp(gam_c_global)
par(mfrow=c(2,2))
gam.check(gam_c_global)
concurvity(gam_c_global, full=FALSE)


# interactions of interest
#all_dat_scale$skua50_cat <- factor(ifelse(all_dat_scale$skua50==1,"y","n"))
# tried a skua interaction with pa_ratio. Came out as significant, but main difference was that subcol with high pa_ratio with a skua within 50m has slighty less negative impact. Really not much data at that end though so don't think this is a good idea. Going to drop it.

k=5
gam_c_globalx <- gam(prod~s(pa_ratio, by=skua50_yn,k=k) +s(mean_slope, by=season,k=k)+s(adjust_mean_elev,by=season,k=k)+s(adjust_mean_aspect, by=season,k=k) +s(mean_solar, by=season,k=k) +s(mean_wind, by=season,k=k)+s(flood_risk_trans, by=season,k=k)+ skua50_yn+ season + s(subcol,k=k, bs="re"), data=all_dat_scale[all_dat_scale$col=="croz",], select=TRUE, method="ML")

summary(gam_c_globalx)
anova(gam_c_globalx)
par(mfrow=c())
plot.gam(gam_c_globalx, pages=2,scale=0, shade=TRUE)

# season interaction with pa_ratio instead of skua
gam_c_globalx2 <- gam(prod~s(pa_ratio, by=season,k=k) +s(mean_slope, by=season,k=k)+s(adjust_mean_elev,by=season,k=k)+s(adjust_mean_aspect, by=season,k=k) +s(mean_solar, by=season,k=k) +s(mean_wind, by=season,k=k)+s(flood_risk_trans, by=season,k=k)+ skua50_yn+ season + s(subcol,k=k, bs="re"), data=all_dat_scale[all_dat_scale$col=="croz",], select=TRUE, method="ML")
summary(gam_c_globalx2)


# check how compare
AICctab(gam_c_globalx2,gam_c_globalx,nobs=276, base=TRUE, weights=TRUE, logLik=TRUE)

# remove variables with edf = 0 and refit: area, slope, solar, flood
gam_c_simp <- gam(prod~s(pa_ratio)+s(adjust_mean_elev)+s(adjust_mean_aspect,k=10, bs="cc")+s(mean_wind)+skua50+season+s(subcol,k=k, bs="re"), data=all_dat_scale[all_dat_scale$col=="croz",], select=TRUE,method="ML")
summary(gam_c_simp)
plot.gam(gam_c_simp, shade=TRUE, pages=1, scale=0)

# model simp with season interaction
gam_c_xseas <- gam(prod~s(pa_ratio, by=season)+ s(adjust_mean_elev,by=season,k=k, bs=) +s(adjust_mean_aspect,by=season,k=10, bs="cc") +s(mean_wind,by=season)+skua50*season+s(subcol,k=k, bs="re"),data=all_dat_scale[all_dat_scale$col=="croz",],select=TRUE, method="ML")
summary(gam_c_xseas)
anova(gam_c_xseas)
plot.gam(gam_c_xseas,pages=2,shade=TRUE, scale=0)

# check how compare
AICctab(gam_c_simp,gam_c_global,gam_c_globalx, gam_c_globalx2,gam_c_xseas,nobs=276, base=TRUE, weights=TRUE, logLik=TRUE)


```
Cross validation attempt at Crozier
```{r cross validation at Crozier}
# try some cross validation ####
# using data scaled for both colonies together to aid comparison

#create table holding out data from 1415
c_s234<- all_dat_scale%>%
  filter(!season=="1415", col=="croz")
gam_c_global_s234 <- gam(prod~s(area, k=k,bs="cr")+s(pa_ratio, k=k, bs="cr")+s(mean_slope,k=k, bs="cr")+s(adjust_mean_elev,k=k, bs="cr")+s(adjust_mean_aspect,k=10, bs="cc")+s(mean_solar,k=k, bs="cr")+s(mean_wind,k=k, bs="cr")+s(flood_risk, k=k, bs="cr")+skua50+season+s(subcol,k=k, bs="re"),data=c_s234,select=TRUE, method="ML")

summary(gam_c_global_s234)
plot.gam(gam_c_global_s234, pages=1, scale=0, shade=T)

c_s1 <- all_dat_scale%>%
  filter(season=="1415", col=="croz")
# predict to 1415
gam_c_pred_s1<- predict(gam_c_global_g1,newdata=c_s1)
rcorr(gam_c_pred_s1, c_s1$prod)
plot(gam_c_pred_s1, c_s1$prod)


# fit model to season 134
c_s134<- all_dat_scale%>%
  filter(!season=="1516", col=="croz")
gam_c_global_s134 <- gam(prod~s(area, k=k,bs="cr")+s(pa_ratio, k=k, bs="cr")+s(mean_slope,k=k, bs="cr")+s(adjust_mean_elev,k=k, bs="cr")+s(adjust_mean_aspect,k=10, bs="cc")+s(mean_solar,k=k, bs="cr")+s(mean_wind,k=k, bs="cr")+s(flood_risk, k=k, bs="cr")+skua50+season+s(subcol,k=k, bs="re"),data=c_s134,select=TRUE, method="ML")

summary(gam_c_global_s134)
plot.gam(gam_c_global_s134, pages=1, scale=0, shade=T)

c_s2 <- all_dat_scale%>%
  filter(season=="1516", col=="croz",!subcol=="d24")%>%
  mutate(season="1415")
# predict to 1516
gam_c_pred_s2<- predict(gam_c_global_s134,newdata=c_s2)
rcorr(scale(gam_c_pred_s2), scale(c_s2$prod))
plot(gam_c_pred_s2, c_s2$prod)


# fit model to season 124
c_s124<- all_dat_scale%>%
  filter(!season=="1617", col=="croz")
gam_c_global_s124 <- gam(prod~s(area, k=k,bs="cr")+s(pa_ratio, k=k, bs="cr")+s(mean_slope,k=k, bs="cr")+s(adjust_mean_elev,k=k, bs="cr")+s(adjust_mean_aspect,k=10, bs="cc")+s(mean_solar,k=k, bs="cr")+s(mean_wind,k=k, bs="cr")+s(flood_risk, k=k, bs="cr")+skua50+season+s(subcol,k=k, bs="re"),data=c_s124,select=TRUE, method="ML")

summary(gam_c_global_s124)
plot.gam(gam_c_global_s124, pages=1, scale=0, shade=T)

c_s3 <- all_dat_scale%>%
  filter(season=="1617", col=="croz", !subcol%in%c("b12", "d24_1", "d24_2", "p55"))%>%
  mutate(season="1415")
# predict to 1617
gam_c_pred_s3<- predict(gam_c_global_s124,newdata=c_s3)
rcorr(scale(gam_c_pred_s3), scale(c_s3$prod))
plot(gam_c_pred_s3, c_s3$prod)

# fit model to season 123
c_s123<- all_dat_scale%>%
  filter(!season=="1718", col=="croz")
gam_c_global_s123 <- gam(prod~s(area, k=k,bs="cr")+s(pa_ratio, k=k, bs="cr")+s(mean_slope,k=k, bs="cr")+s(adjust_mean_elev,k=k, bs="cr")+s(adjust_mean_aspect,k=10, bs="cc")+s(mean_solar,k=k, bs="cr")+s(mean_wind,k=k, bs="cr")+s(flood_risk, k=k, bs="cr")+skua50+season+s(subcol,k=k, bs="re"),data=c_s123,select=TRUE, method="ML")

summary(gam_c_global_s123)
plot.gam(gam_c_global_s123, pages=1, scale=0, shade=T)

c_s4 <- all_dat_scale%>%
  filter(season=="1718", col=="croz",!subcol%in%c("b10", "b25", "c58", "n10", "n11", "p22-23", "p40_1", "s33", "t18", "t7"))%>%
  mutate(season="1516",subcol="m5")
# predict to 1718
gam_c_pred_s4<- predict(gam_c_global_s123,newdata=c_s4)
rcorr(scale(gam_c_pred_s4), scale(c_s4$prod))
plot(gam_c_pred_s3, c_s3$prod)

# predict to years using model fit to all data
gam_c_gpred_s1 <- predict(gam_c_global, newdata=c_s1)
rcorr(scale(gam_c_gpred_s1), scale(c_s1$prod))

c_s2 <- all_dat_scale%>%
  filter(season=="1516", col=="croz")
gam_c_gpred_s2 <- predict(gam_c_global, newdata=c_s2)
rcorr(scale(gam_c_gpred_s2), scale(c_s2$prod))


c_s3 <- all_dat_scale%>%
  filter(season=="1617", col=="croz")
gam_c_gpred_s3 <- predict(gam_c_global, newdata=c_s3)
rcorr(scale(gam_c_gpred_s3), scale(c_s3$prod))

c_s4 <- all_dat_scale%>%
  filter(season=="1718", col=="croz")
gam_c_gpred_s4 <- predict(gam_c_global, newdata=c_s4)
rcorr(scale(gam_c_gpred_s4), scale(c_s4$prod))

```
Gamms for Royds
```{r Royds Gamms, include=FALSE}
k=4
gam_r_global <- gam(prod~s(area, by=skua50, k=k)+s(pa_ratio, by=skua50,k=k)+s(mean_slope, by=skua50, k=k)+s(adjust_mean_elev, k=k)+s(mean_aspect,k=10, bs="cc")+ s(mean_solar,k=k)+ s(mean_wind,k=k)+ s(flood_risk_trans,k=k)+s(subcol,bs="re")+skua50+season, data=all_dat_scale[all_dat_scale$col=="royds",],select=TRUE, method="ML")

summary(gam_r_global)
plot.gam(gam_r_global, pages=1, shade=T, residuals=T,scale=0)
gam.check(gam_r_global) # looks good

all_dat_scale[all_dat_scale$pa_ratio>1.75&all_dat_scale$col=="royds",]

# remove all vars with edf=0: area, aspect, wind, flood, subcol (?)
# k=8
gam_r_simp1 <- gam(prod~s(pa_ratio,k=k)+s(mean_slope,k=k)+s(adjust_mean_elev,k=k)+s(mean_solar,k=k)+skua50+season, data=all_dat_scale[all_dat_scale$col=="royds",], method="ML", select=TRUE)
summary(gam_r_simp1)
plot.gam(gam_r_simp1, pages=1, shade=T, residuals=T, scale=0)

# check how compare
AICctab(gam_r_global,gam_r_simp1,nobs=79, base=TRUE, weights=TRUE, logLik=TRUE)
# alomost identidal

# add season interaction to simp1 model
k=5
gam_r_simp1xseas <- gam(prod~s(pa_ratio,k=k, bs="cs")+ s(mean_slope,by=season,k=k, bs="cs")+ s(adjust_mean_elev,by=season,k=k, bs="cs")+ s(mean_solar,by=season,k=k, bs="cs")+ s(subcol,k=k,bs="re")+skua50+season, data=all_dat_scale[all_dat_scale$col=="royds",], method="ML")
summary(gam_r_simp1xseas)
plot.gam(gam_r_simp1xseas, pages=1,shade=T, residuals=T)

AICctab(gam_r_simp1,gam_r_simp1xseas,nobs=79, base=TRUE, weights=TRUE, logLik=TRUE)

# season interaction at Royds doesn't improve fit


# Crozier and Royds together
# Maybe I don't need to do this? Just a different way of getting the same answer?
# season interaction more important than colony interaction
# think maybe all I want from this is to find out which variables are important at both
gam_cr_global <- gam(prod~s(area)+s(pa_ratio)+ s(mean_slope)+ s(adjust_mean_elev)+ s(mean_aspect, bs="cc")+ s(mean_wind)+ s(mean_solar)+ skua50+ season+ col+s(subcol, bs="re"),select=TRUE, data=all_dat_scale, method="REML")
summary(gam_cr_global)
anova(gam_cr_global)
plot.gam(gam_cr_global, pages=1, shade=TRUE,scale=0)    

# drop vars with edf=0
gam_cr_simp1 <- gam(prod~s(pa_ratio, k=k, bs="cs")+s(adjust_mean_elev,k=k, bs="cs")+ s(mean_aspect,k=k, bs="cc")+s(subcol, bs="re")+skua50+season+ col, data=all_dat_scale, method="ML")
summary(gam_cr_simp1)
plot.gam(gam_cr_simp1,page=1,shade=TRUE,scale=0)
# check if get the same results
AICctab(gam_cr_global,gam_cr_simp1,nobs=283, base=TRUE, weights=TRUE, logLik=TRUE)

# add skua interaction to test skua hypothesis
gam_cr_simp2 <- gam(prod~s(pa_ratio, k=k, bs="cs")+s(adjust_mean_elev,k=k, bs="cs")+ s(mean_aspect,k=k, bs="cc")+s(subcol, bs="re")+skua50*col+season, data=all_dat_scale, method="ML")
summary(gam_cr_simp2)
plot.gam(gam_cr_simp2,page=1,shade=TRUE,scale=0)
# skua interaction not supported



```
Predict Breeding success to held out counts
```{r Predict BS}
library(raster)
library(Hmisc)
# fit model with unscaled data and "REML" for prediction
gam_c_simp1_pred <- gam(prod~s(pa_ratio)+s(adjust_mean_elev)+ s(mean_aspect, k=10, bs="cc") + s(mean_wind)+skua50+season+s(subcol,k=k, bs="re"), data=all_dat[all_dat$col=="croz",], method="REML")
summary(gam_c_simp1_pred)
plot.gam(gam_c_simp1_pred, shade=TRUE, pages=1, scale=0, residuals=TRUE)


# Predict to held out m subcol ####
c_newdat <- c_ct_meas%>%
  dplyr::select(col,season, subcol,prod,area,pa_ratio,mean_slope,adjust_mean_elev,mean_elev,mean_wind,skua50)%>%
  mutate(season=factor(season))%>%
# select only one year # remove s3 because it's an outlier
  filter(season%in%c("1718"),!subcol=="s3",col=="croz",subcol%in%factor(m_index))
c_dat_hold<- filter(c_dat_hold, !subcol=="n11")

m_pred <- predict.gam(gam_c_simp1_pred,exclude="subcol",newdata=c_dat_hold)

rcorr(c_dat_hold$prod,m_pred)
plot(c_dat_hold$prod,m_pred)

# predict to M from previous years
m_dat_old <- c_ct_meas%>%
  dplyr::select(col,season,area_name, subcol,active_ct,prod,area,perim,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_elev,mean_wind,mean_solar,flood_risk,skua50,skua100)%>%
  mutate(season=factor(season),subcol=factor(subcol))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1213", "1314"),!prod=="NA"&!is.na(pa_ratio), subcol%in%m_index)%>%
  mutate(adjust_mean_aspect=ifelse(!is.na(mean_aspect)&mean_aspect>300,mean_aspect-360,mean_aspect), season="1415")

gam_c_gsimp_mpred <- predict(gam_c_simp1_pred, newdata=m_dat_old)
rcorr(scale(gam_c_gsimp_mpred), scale(m_dat_old$prod))

# this doesn't appear to work very well, perhaps because relationship is noisy and the range of data in M is small

```
Predict Productivity Spatially
```{r Predict prod to space}
# read in rasters to use for prediction
c_skua50m <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_skua50mbin_rast.tif")
ext<-extent(c_skua50m)

c_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_pa_ratio_rast.tif"),ext)

c_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_slope_clip.tif"),ext)

c_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_elev_clip.tif"),ext)+47

c_wind <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_hillshade_wind_clip.tif"),ext)

plot(c_elev)

croz_stack <- stack(c_pa_ratio,c_skua50m, c_slope,c_elev,c_wind)
names(croz_stack)<-c("pa_ratio","skua50","mean_slope", "adjust_mean_elev","mean_wind")

season <- factor('1415', levels=levels(c_dat$season))
subcol <- factor("b33",levels=levels(c_dat$subcol))
add<- data.frame(season, subcol)

c_pred_simpl <- predict(croz_stack,gam_c_simp1_pred,const=add, type="response")
plot(c_pred_simpl)

c_pred_simpl_scale <- scale(c_pred_simpl)
plot(c_pred_simpl_scale)

writeRaster(c_pred_simpl_scale, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_prod_scale2.tif", format="GTiff", overwrite=TRUE)

writeRaster(c_pred_simpl, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_prod2.tif", format="GTiff", overwrite=TRUE)

# predict to available habitat ####

# read in layer with available habitat
c_avail <-  raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack_unoccupied/c_avail_hab_2014.tif")
plot(c_avail)
getValues(c_avail,400)

ext_avail <- extent(c_avail)

# make layer with constant pa_ratio
c_pa_ratio_avail <- c_avail
c_pa_ratio_avail[c_pa_ratio_avail==1]<-3

plot(c_pa_ratio_avail)
c_pa_ratio_avail[400,]
# read in raster layer with dist to skua
c_skua50m_avail <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack_unoccupied/skua50m_dist_rast_bin.tif"), ext_avail)
# replace NA with 0
c_skua50m_avail[is.na(c_skua50m_avail)]<-0
head(c_skua50m_avail[is.na(c_skua50m_avail)])
plot(c_skua50m_avail)

# mask other layers to match
#c_slope_avail <- crop(c_slope,ext_avail)
c_skua50m_avail<- mask(c_skua50m_avail, c_avail)
c_slope_avail <- mask(c_slope,c_avail)
c_elev_avail <- mask(c_elev, c_avail)
c_wind_avail <- mask(c_wind, c_avail)


c_stack_avail <- stack(c_pa_ratio_avail,c_skua50m_avail, c_slope_avail,c_elev_avail,c_wind_avail)
names(c_stack_avail)<-c("pa_ratio","skua50","mean_slope", "adjust_mean_elev","mean_wind")

season <- factor('1415', levels=levels(c_dat$season))
subcol <- factor("b33",levels=levels(c_dat$subcol))
add_avail<- data.frame(season, subcol)

c_pred_avail <- predict(c_stack_avail,gam_c_simp1_pred,const=add_avail, type="response")
c_pred_avail_scale <- scale(c_pred_avail)
plot(c_pred_avail)

writeRaster(c_pred_avail_scale, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_prod_avail_scale4.tif", format="GTiff", overwrite=TRUE)



t <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/tables/croz_bqi_pred_prod_test.txt", header=TRUE)

t<- t%>%
  mutate(RASTERVALU=ifelse(RASTERVALU==-9999,NA,RASTERVALU))%>%
  filter(Season_yr>2011)
rcorr(t$BQI_A, t$RASTERVALU)
dat10 <- c_dat%>%
  dplyr::select(subcol,prod)

t <- rename(t,subcol_anom=SELECTED_SUBCOL_)
t2 <- left_join(t,subcol_anom,by="subcol")
Hmisc::rcorr(t2$MEAN,t2$ann_prod_anom)
```