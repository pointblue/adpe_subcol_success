---
title: "Analysis of variation in reproductive success by subcolony"
author: "Annie Schmidt"
date: "June 2, 2016"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

```{r load libraries and data}
library(ggplot2)
library(dplyr)
library(tidyr)
library(readr)
library(mgcv)
# library(bbmle)
library(Hmisc)
#library(raster)
library(stringr)
library(gridExtra)
# library(dismo)
# library(gbm)

#Set working directory
# setwd("Z:/Informatics/S031/analyses/aschmidt/subcol_var")

  
# Define functions #### 
# correlation matrix of data
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- cor(x, y, use="complete.obs")
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * abs(r))
}


# read in count data files with subcolony attributes (created by croz(royd)_subcol_ct_data_prep.R) ####
# Crozier
c_ct_meas <- read.csv("data/croz_selected_meas_ct_all_v8.csv")

# Royds
r_ct_meas <- read_csv("data/royds_selected_meas_ct_all.csv")


```

Format data for modeling
```{r format data, echo = FALSE}
# select columns for analysis
# create index of m subcolonies to hold out of analysis 
# have a disproportionate number from area M which is where most of the KA birds are
# so holding out some of the M subcolonies to predict to and correlate prediction with BQI would be good?

c_dat <- c_ct_meas%>%
  dplyr::select(-FID,-mean_elev, -perim)%>%
  mutate(season=factor(season),subcol=factor(subcol), m=ifelse(area_name=="m","y","n"), skua50_yn=factor(ifelse(skua50==1,"y","n")),
         flood_risk_bin=ifelse(flood_risk<10,1,0),
         flood_risk_trans=log1p(flood_risk),
         flow_acc_log=log(flow_acc))%>%
   #shift aspect values >300 to other side of 0
         #=ifelse(!is.na(mean_aspect)&mean_aspect>300,mean_aspect-360,mean_aspect), m_not=ifelse(area_name=="m","m","other"))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1415","1516","1617","1718"),!subcol=="s3",!prod=="NA"&!is.na(pa_ratio))%>%
  group_by(subcol)%>%
  mutate(growth=(active_ct/lag(active_ct)-1)*100)%>%
  ungroup()%>%
  rename(mean_flow_acc=flow_acc)

# # set levels for season to allow older seasons to be used
# levels(c_dat$season)<-levels(factor(c_ct_meas$season))


# Format Royds data
r_dat <- r_ct_meas%>%
  dplyr::select(-FID,-perimeter,-mean_elev)%>%
  mutate(season=factor(season),subcol=factor(subcol),col=factor(col),skua50_yn=factor(ifelse(skua50==1,"y","n")), flood_risk_trans=log1p(flood_risk), flow_acc_log=log(mean_flow_acc))%>%
  replace_na(list(flood_risk=0,flood_risk_trans=0))%>%
  # active count from 13 in 1617 looks off, exclude
  filter(!is.na(active_ct), !active_ct==0,!(subcol=="13"&season=="1617"))
# one slope value for Royds 1b seems off (unlikely it's a 50deg slope)
# # Setting it to value from other overpalling pixel = Pixel value	25.368334
# setting slope or 1b to value for other pixel that overlaps (more reasonable)
r_dat[r_dat$subcol=="1b","mean_slope"]=25.3683  
# crazy slope causes other variables to be off also, need to reset these also to next pixel
# Flow acc change to 6
r_dat[r_dat$subcol=="1b","mean_flow_acc"]=6
r_dat[r_dat$subcol=="1b","flow_acc_log"]=log(6)
# wind shelt to -0.016
r_dat[r_dat$subcol=="1b","mean_windshelt"]=-0.016
# aspect to 253.100
r_dat[r_dat$subcol=="1b","mean_aspect"]=253.100
# elevation to -45.248047+47
r_dat[r_dat$subcol=="1b","adjust_mean_elev"]=-45.248047+47

# data.frame(filter(r_dat,subcol=="1b"))


# Combine data
all_dat <- c_dat%>%
  full_join(r_dat)%>%
  mutate(subcol=as.factor(subcol), col=as.factor(col),skua50_yn=factor(skua50_yn), season=factor(season))

# scale all data to make model fitting easier
all_dat_scale <- all_dat%>%
  mutate_at(vars(active_ct,prod,area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_wind,mean_windshelt,mean_windshelt100m, mean_windshelt100mp8,mean_flow_acc,flow_acc_log1p,flood_risk_trans),funs(scale))%>%
  mutate(col_bin=ifelse(col=="royds",1,0))%>%
  unite(col_seas,col,season,sep="_", remove=FALSE)%>%
  mutate(col_seas=factor(col_seas))

# c_dat_scale <- c_dat%>%
#  mutate_at(vars(active_ct,prod,area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_wind, mean_windshelt,flow_acc,flow_acc_log1p,dist_outer,mean_n10_dist),funs(scale))

```            

Data vis
```{r figs}
pairs(c_dat[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log","skua50")],lower.panel = panel.smooth, upper.panel = panel.cor)


# melt data for data vis
subcol_attr <- all_dat_scale%>%
  dplyr::select(-flood_risk,-active_ct,-ch_ct,-prod,-growth,-skua50, -skua50_yn, -flood_risk_bin)%>%
  # dplyr::slice(1)%>%
  gather(subcol_attr,value=measurement,-col,-season,-area_name,-subcol)

# # plot subcol attributes by col
# p<-ggplot(subcol_attr, aes(x=col, y=measurement,fill=subcol_attr))+
#   geom_boxplot()+
#   facet_wrap(~subcol_attr,scales="free")
# 
# # plot subcol attributes at croz by season
# p2<- ggplot(filter(subcol_attr,col=="croz"), aes(x=subcol_attr,y=measurement,fill=season))+
#               geom_boxplot()
# # plot subcol attributes in m vs outside m
# p3_dat <- subcol_attr%>%
#   mutate(m = ifelse(area_name=="m", "y","n"))%>%
#   filter(col=="croz")
# p3<- ggplot(p3_dat, aes(x=subcol_attr,y=measurement,fill=m))
# p3 + geom_boxplot()
            
# plot with M counts compared to outside of M
# m_cts <- c_ct_meas%>%
#   select(season,area_name, subcol, prod)%>%
#   mutate(season=factor(season), m_note=ifelse())%>%
#   filter(area_name=="m", season%in%c('1415','1516','1617','1718'))

ggplot(c_dat, aes(season,prod, fill=m))+
  geom_boxplot()

ggplot(c_dat, aes(m,prod, fill=m))+
  geom_boxplot()

c_dat%>%
  filter(season%in%c("1415","1516","1617","1718"))%>%
ggplot(aes(area_name,prod))+
  geom_boxplot(fill="dodgerblue")

# test mean productivity between m and other areas
t.test(c_dat$prod[c_dat$m=="y"],c_dat$prod[c_dat$m=="n"])
# test between M and area with highest mean (qr): not significant
t.test(c_dat$prod[c_dat$area_name=="m"],c_dat$prod[c_dat$area_name=="qr"])
# test between M and loweset mean (l): significant
t.test(c_dat$prod[c_dat$area_name=="m"],c_dat$prod[c_dat$area_name=="l"])
# test between highest (qr) and lowest (l): significant
t.test(c_dat$prod[c_dat$area_name=="qr"],c_dat$prod[c_dat$area_name=="l"])

# M time series plot
c_ct_meas%>%
  mutate(season=factor(season), m_not=ifelse(area_name=="m","m","other"))%>%
  ggplot(aes(season,prod, fill=m_not))+
  geom_boxplot()




# plot ave by subcol
sub4 <- c_dat%>%
  dplyr::select(subcol,prod)%>%
  group_by(subcol)%>%
  summarise(count=n())%>%
  filter(count==4)

n_subcol_cts <- c_ct_meas%>%
  filter(area_name=="m")%>%
  group_by(subcol)%>%
  summarise(count=n())%>%
  filter(count>=10)

c_dat%>%
  dplyr::select(season,prod)%>%
  group_by(season)%>%
  summarise(count=n())
r_dat%>%
  dplyr::select(season,prod)%>%
  group_by(season)%>%
  summarise(count=n())


  #annotate("text", x = 1:length(n_subcol_cts$subcol),y =1.65, label = n_subcol_cts$n, col="blue") + 
  #labs(y = "chicks per active nest")

# Plot prod by subcol
c_dat%>%
  filter(subcol%in%sub4$subcol)%>%
  ggplot(aes(subcol,prod)) + 
  geom_boxplot(fill="lavender") 

# Two panel plot with m timeseries and subcols with 4 counts
p_sub4_box <-c_dat%>%
  filter(subcol%in%sub4$subcol)%>%
  ggplot(aes(area_name,prod)) + 
  geom_boxplot(fill="coral") 
p_m_box <- c_ct_meas%>%
  mutate(season=factor(season), m_not=ifelse(area_name=="m","m","other"))%>%
  ggplot(aes(season,prod))+
  geom_boxplot(fill="dodgerblue")

grid.arrange(p_sub4_box,p_m_box)
# Croz and Royds together
# Read in historic royds counts
r_ct_all <- read.csv("data/royds_all_ct_clean_thru1718.csv",header=TRUE)

c_ct_meas%>%
  full_join(r_ct_all)%>%
  dplyr::select(col,subcol,season,prod)%>%
#   # dplyr::slice(1)%>%
#   gather(subcol_attr,value=measurement,-col,-season,-area_name,-subcol)
# %>%
  mutate(season=factor(season))%>%
  ggplot(aes(season,prod, fill=col))+
  geom_boxplot()+
  theme_classic()

c_m_box <- c_ct_meas%>%
  mutate(season=factor(season), m_not=ifelse(area_name=="m","m","other"))%>%
  ggplot(aes(season,prod))+
  geom_boxplot(fill="dodgerblue")



c_ct_meas%>%
  filter(area_name=="m", !subcol=="mis")%>%
  full_join(n_subcol_cts)%>%
  ggplot(aes(subcol,prod)) + 
  geom_boxplot(fill="dodgerblue")+
  annotate("text", x = 1:length(n_subcol_cts$subcol),y =1.65, label = n_subcol_cts$count, col="blue") + 
  labs(y = "chicks per active nest")

c_ct_meas%>%
  filter(subcol%in%n_subcol_cts$subcol)%>%
  ggplot(aes(subcol,prod)) + 
  geom_boxplot() +
  annotate("text", x = 1:length(n_subcol_cts$subcol),y =1.65, label = n_subcol_cts$count, col="blue") + 
  labs(y = "chicks per active nest")

t.test(c_ct_meas$prod[c_ct_meas$subcol=="m5"],c_ct_meas$prod[c_ct_meas$subcol=="m30"])

# Plot variance in counts by subcol area

var_by_area <- c_dat%>%
  filter(subcol%in%sub4$subcol)%>%
  group_by(subcol)%>%
  summarise(var=var(prod),area=mean(area))

  ggplot(var_by_area,aes(area,var))+
  geom_point()+
    geom_smooth()
  
c_var_gam <- gam(var~s(area), data=var_by_area, method="ML")
summary(c_var_gam)
plot.gam(c_var_gam, shade=TRUE, residuals=TRUE, cex=2)
  
rcorr(var_by_area$area, var_by_area$var)


# 
hist(r_dat$prod)

# Plot weather data ####
# Read in weather data 
wthr <- read.csv("data/weather_summary_1415-1718.csv", header=TRUE)%>%
  mutate(season=factor(season), DATE=as.Date(DATE),jdate=as.POSIXlt(DATE)$yday)%>%
  filter(jdate>333&jdate<=365)
wind_dir <- c("N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW")
spd <-30

# Plots of wind speed and direction ####

# Plot number of times each direction recorded
wthr%>%
  filter(!is.na(GUSTMPH))%>%
  group_by(season, DIR)%>%
  summarise(perc_days=n()/nrow(.))%>%
dplyr::slice(match(wind_dir,DIR))%>%
  ggplot(aes(DIR, perc_days))+
  geom_bar(stat="identity")+
  facet_wrap(~season, nrow=4)

# Plot direction of high wind events
hwe<- wthr%>%
  filter(GUSTMPH>spd)%>%
  group_by(season)%>%
  summarise(nobs=n())%>%
  ggplot(aes(season,nobs))+
  geom_bar(stat="identity")+
  ylab("High Wind Events \n(# obs of >30mph)")


# Plot of temperature
p_temp<-wthr%>%
  group_by(DATE)%>%
  arrange(LOWTEMP)%>%
  dplyr::slice(1)%>%
  group_by(season)%>%
  summarise(mean_lowtemp=mean(LOWTEMP, na.rm=TRUE),se=sd(LOWTEMP, na.rm=TRUE)/sqrt(n()))%>%
  ggplot(aes(season,mean_lowtemp))+
           geom_bar(stat="identity")+  
  geom_errorbar(aes(ymin=mean_lowtemp - se,ymax=mean_lowtemp+se), width=.2,
                position=position_dodge(.9))+
  xlab("Season")+
  ylab("Mean Low Temp (Dec)")
# +
#   guides(fill=guide_legend(title=NULL))+
#   scale_fill_manual(values=c("deeppink","seagreen3"),name=NULL,breaks=c("CL", "RL"),labels=c("Control Levee", "Restored Levee"))


temp <- wthr%>%
  group_by(DATE)%>%
  arrange(LOWTEMP)%>%
  dplyr::slice(1)%>%
  group_by(season)

t.test(temp$LOWTEMP[temp$season=="1415"],temp$LOWTEMP[temp$season=="1516"]) # significant
t.test(temp$LOWTEMP[temp$season=="1516"],temp$LOWTEMP[temp$season=="1617"])
t.test(temp$LOWTEMP[temp$season=="1617"],temp$LOWTEMP[temp$season=="1718"])
t.test(temp$LOWTEMP[temp$season=="1516"],temp$LOWTEMP[temp$season=="1718"])
t.test(temp$LOWTEMP[temp$season=="1415"],temp$LOWTEMP[temp$season=="1617"])
t.test(temp$LOWTEMP[temp$season=="1415"],temp$LOWTEMP[temp$season=="1718"]) # significant


# Number of observations with snow

snow_days <- wthr%>%
  filter(str_detect(NOTES, "snow|Snow|SNOW"))%>%
  group_by(season, DATE)%>%
  dplyr::slice(1)%>%
  group_by(season)%>%
  summarise(snow_days=n())%>%
  ggplot(aes(season,snow_days))+
  geom_bar(stat="identity")+
  xlab("Season")+
  ylab("Snow days")

mean_prod<-all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  ggplot(aes(season,mean_prod,fill=col))+
           geom_bar(stat="identity", position="dodge")+  
  geom_errorbar(aes(ymin=mean_prod - se,ymax=mean_prod+se), width=.2,
                position=position_dodge(.9))+
  xlab("Season")+
  ylab("Mean Productivity \n(chicks fledged per pair)")


var_prod<-all_dat%>%
  group_by(col,season)%>%
  summarise(var_prod=var(prod, na.rm=TRUE))%>%
  ggplot(aes(season,var_prod, fill=col))+
           geom_bar(stat="identity", position="dodge")+
  xlab("Season")+
  ylab("Variance in Productivity")


grid.arrange(grobs=list(mean_prod,hwe, p_temp), nrow=4)



```

Crozier GAMM
```{r Crozier GAMM}
# Starting with model with all variables of interest subcol id as random effect
# using REML based on recommendation in Marra and Wood 2011
# # Except if I want to compare models with different fixed effects I shouldn't
# # https://stats.stackexchange.com/questions/116770/reml-or-ml-to-compare-two-mixed-effects-models-with-differing-fixed-effects-but?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
# # thread suggests using REML because it does a better job with random effects on just your final model for inference and prediction


# Starting with model with all variables of interest and season interaction
# First create table with data to hold out from model fitting
# Select counts from subcol with less than 2 counts
# want to used the scaled data for this

# use subcol that only have one count?

# just select random rows in data frame
# filter for just croz
c_dat_scale <- all_dat_scale%>%
  filter(col=="croz")

# set.seed(13)
# # want to hold out from only subcols that have 4 counts
# all4 <- c_dat_scale%>%
#   group_by(subcol)%>%
#   summarise(counts=n())%>%
#   filter(counts>3)%>%
#   select(subcol)
# 
# c_hold_index <- sample(1:nrow(c_dat_scale), 30,replace=FALSE)
# 
# c_dat_mod <-c_dat_scale[-c_hold_index,]
# c_dat_hold <- c_dat_scale[c_hold_index,]


# Fit model with no season interactions
# c_base <-gam(prod~s(area, k=k) + s(pa_ratio, k=k)+s(mean_slope, k=k) +s(mean_aspect,k=k, bs="cc") + s(adjust_mean_elev, k=k)+s(mean_windshelt,k=k)+s(flow_acc_log, k=k)+skua50_yn+season+s(subcol, bs="re"), data=c_dat_scale, select=TRUE, method="ML")
# 
# summary(c_base)
# anova(c_base)
# plot.gam(c_base,pages=1, shade=TRUE, scale=0)


# remove annual mean so just modeling the spatial variability, not the annual variability
ann_prod_anom<-all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod)%>%
  mutate_at(vars(area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,mean_windshelt100m,mean_windshelt100mp8,flow_acc_log1p),funs(scale))
# plot(ann_prod_anom$subcol,ann_prod_anom$prod_anom)

# ann_prod_anom<- all_dat%>%
#   group_by(col,season)%>%
#   mutate(prod_anom=scale(prod))%>%
#   ungroup()%>%
#   mutate_at(vars(area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,flow_acc_log),funs(scale))

mean(ann_prod_anom$prod_anom[ann_prod_anom$col=="royds"&ann_prod_anom$season=="1415"])

plot(ann_prod_anom$season, ann_prod_anom$prod_anom)  

k=6
c_base_anom <-gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=10, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50_yn+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
summary(c_base_anom)
anova(c_base_anom)
plot.gam(c_base_anom,pages=1, shade=TRUE)

gam.vcomp(c_base_anom)
par(mfrow=c(2,2))
gam.check(c_base_anom)
concurvity(c_base_anom, full=FALSE)

croz_ann_prod <- filter(ann_prod_anom,col=="croz")
predict_cbase <- predict(c_base_anom)
plot(croz_ann_prod$prod_anom,predict_cbase)

rcorr(croz_ann_prod$prod_anom,predict_cbase)

c_base_anom_REML <-gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=10, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50_yn+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="REML")
predict_cbase_REML <- predict(c_base_anom_REML)
plot(croz_ann_prod$prod_anom,predict_cbase_REML)

rcorr(croz_ann_prod$prod_anom,predict_cbase_REML)
gam.check(c_base_anom_REML)

# Calculate proportion deviance explained by each model
# b <- gam(y~s(x1)+s(x2))
# > b1 <- gam(y~s(x1),sp=b$sp[1])
# > b2 <- gam(y~s(x2),sp=b$sp[2])
# > b0 <- gam(y~1)
# > ## calculate proportions deviance explained...
# > (deviance(b1)-deviance(b))/deviance(b0) ## prop explained by s(x2)
# > (deviance(b2)-deviance(b))/deviance(b0) ## prop explained by s(x1)

cb2 <- gam(prod_anom~s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), method="REML")
summary(cb2)
plot.gam(cb2, pages=1, shade=TRUE)


cb2 <- gam(prod_anom~s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), method="REML")


c_seasonx_anom <-gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev,by=season, k=k)+s(mean_slope, by=season, k=k) +s(mean_aspect,by=season,k=10, bs="cc") +s(mean_windshelt,by=season,k=k)+s(flow_acc_log1p,by=season, k=k)+skua50_yn+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
summary(c_seasonx_anom)
plot.gam(c_seasonx_anom,pages=1, shade=TRUE)


# # 
# c_seasonx <- gam(prod~s(area,by=season,k=k)+ s(pa_ratio,by=season,k=k) +s(mean_slope, by=season,k=k)+s(adjust_mean_elev,by=season,k=k)+s(mean_aspect, by=season,k=k, bs="cc") +s(mean_windshelt, by=season,k=k)+s(flow_acc_log, by=season, k=k)+skua50_yn*season + s(subcol, bs="re"), data=c_dat_scale, select=TRUE, method="ML")
# 
# summary(c_seasonx)
# anova(gam_c_globalx)
# par(mfrow=c())
# plot.gam(c_seasonx, pages=2, shade=TRUE)
# 
# gam.check(c_seasonx)

# check residuals for normality?

gam.vcomp(gam_c_global)
par(mfrow=c(2,2))
gam.check(c_base)
concurvity(c_base, full=FALSE)


# check how compare
AICctab(c_base,c_seasonx,nobs=292, base=TRUE, weights=TRUE, logLik=TRUE)

library(bbmle)
AICctab(c_base_anom,c_seasonx_anom,nobs=292, base=TRUE, weights=TRUE, logLik=TRUE)


```

Gamms for Royds
```{r Royds Gamms, include=FALSE}
r_dat_mod <- all_dat_scale%>%
  filter(col=="royds")
# can't fit this model with k=4 (minimun possible)
# gam_r_globalx <- gam(prod~s(area, by=season, k=k)+s(pa_ratio,by=season,k=k)+s(mean_slope,by=season, k=k)+s(adjust_mean_elev, by=season,k=k)+s(mean_aspect,by=season,k=k, bs="cc")+ s(mean_wind,by=season,k=k)+ s(flood_risk_trans,by=season,k=k)+s(subcol,bs="re")+skua50_yn*season, data=r_dat_mod,select=TRUE, method="ML")
# k=5
# r_base <- gam(prod~s(area, k=k)+s(pa_ratio,k=k)+s(mean_slope, k=k)+s(mean_aspect,k=k, bs="cc")+ s(mean_windshelt,k=k)+ s(flow_acc_log,k=k)+s(subcol,bs="re")+skua50_yn+season, data=r_dat_mod,select=TRUE, method="ML")

k=4
r_base_anom <- gam(prod_anom~s(area, k=k)+s(pa_ratio,k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k)+s(mean_aspect,k=k, bs="cc")+ s(mean_windshelt,k=k)+ s(flow_acc_log,k=k)+s(subcol,bs="re")+skua50_yn, data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML")

summary(r_base_anom)
plot.gam(r_base_anom, pages=1, shade=T, residuals=T)
gam.check(gam_r_global) # looks pretty good, some skew in the residuals

# 
# k=4
# r_seasonx <-  gam(prod~s(area,k=k) + s(pa_ratio,k=k)+s(mean_slope,by=season,k=k) +s(mean_aspect, by=season,bs="cc", k=k) +s(mean_windshelt,by=season,k=k)+ s(flow_acc_log,by=season,k=k)+ skua50_yn+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="ML")
# summary(r_seasonx)
# plot(r_seasonx, pages=2, shade=TRUE)
# gam.check(r_seasonx)
k=4
r_seasonx_anom <-  gam(prod_anom~s(area,k=k) + s(pa_ratio,k=k)+ s(adjust_mean_elev,by=season, k=k)+s(mean_slope,by=season,k=k) +s(mean_aspect, by=season,bs="cc", k=k) +s(mean_windshelt,by=season,k=k)+ s(flow_acc_log,by=season,k=k)+ skua50_yn +s(subcol, bs="re"), data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="ML")
summary(r_seasonx_anom)
plot(r_seasonx_anom, pages=2, shade=TRUE)


AICctab(r_base,r_seasonx,nobs=86, base=TRUE, weights=TRUE, logLik=TRUE)
AICctab(r_base_anom,r_seasonx_anom,nobs=86, base=TRUE, weights=TRUE, logLik=TRUE)

```


Model Croz and Royds together
```{r Crozier and Royds gamms together}

# Hold out data

set.seed(13)
cr_hold_index <- sample(1:nrow(all_dat_scale), 35,replace=FALSE)

all_dat_mod <-all_dat_scale[-cr_hold_index,]
all_dat_hold <- all_dat_scale[cr_hold_index,]


k=4
cr_base <- gam(prod~s(area, k=k)+s(pa_ratio,k=k)+ s(mean_slope,k=k)+ s(adjust_mean_elev,k=k)+ s(mean_aspect, bs="cc",k=k)+ s(mean_windshelt,k=k) + s(flow_acc_log,k=k) + skua50_yn+ season+ col+s(subcol, bs="re"),select=TRUE, data=all_dat_mod, method="ML")
summary(cr_base)

plot.gam(cr_base, pages=1, shade=TRUE)   


cr_xcol <- gam(prod~s(area, k=k, by=col)+s(pa_ratio, k=k, by=col)+ s(mean_slope,k=k,  by=col)+ s(adjust_mean_elev, k=k, by= col)+ s(mean_aspect,k=k, bs="cc", by=col)+ s(mean_windshelt, k=k,by= col) + s(flow_acc_log, k=k,by=col) + skua50_yn*col+ season*col+s(subcol, bs="re"),select=TRUE, data=all_dat_mod, method="ML")
summary(cr_xcol)
anova(gam_cr_global)
plot.gam(cr_xcol, pages=1, shade=TRUE, residuals=TRUE)    


cr_xseas <- gam(prod~s(area,k=k, by=season)+s(pa_ratio, k=k,by=season)+ s(mean_slope,k=k, by=season)+ s(adjust_mean_elev, k=k,by= season)+ s(mean_aspect, k=k,bs="cc", by=season)+ s(mean_windshelt,k=k, by= season) + s(flow_acc_log, k=k,by=season) + skua50_yn*season+ col*season+s(subcol, bs="re"),select=TRUE, data=all_dat_mod, method="ML")
summary(gam_cr_globalxseas)
anova(gam_cr_global)
plot.gam(gam_cr_global, pages=1, shade=TRUE)


# cr_xcolseas2 <- gam(prod~s(area,k=k, by=col_seas)+ s(area,k=k, by=col_seas)+s(pa_ratio, k=k,by=season)+s(pa_ratio, k=k,by=col_bin)+ s(mean_slope,k=k, by=season)+s(mean_slope,k=k, by=col_bin)+ s(adjust_mean_elev, k=k,by= season)+s(adjust_mean_elev, k=k,by= col_bin)+ s(mean_aspect, k=k,bs="cc", by=season)+s(mean_aspect, k=k,bs="cc", by=col_bin)+ s(mean_windshelt,k=k, by= season) + s(mean_windshelt,k=k, by= col_bin)+ s(flow_acc_log, k=k,by=season) +  s(flow_acc_log, k=k,by=col_bin) + skua50_yn*season+ skua50_yn*col_bin + col_bin*season+s(subcol, bs="re"),select=TRUE, data=all_dat_scale, method="ML")
summary(cr_xcolseas2)
# anova(gam_cr_global)
# plot.gam(cr_xcolseas, pages=3, shade=TRUE)
# gam.check(cr_xcolseas)


cr_xcolseas2 <- gam(prod~s(area,k=k, by=col_seas)+s(pa_ratio, k=k,by=col_seas)+ s(mean_slope,k=k, by=col_seas)+ s(adjust_mean_elev, k=k,by= col_seas)+ s(mean_aspect, k=k,bs="cc", by=col_seas)+ s(mean_windshelt,k=k, by= col_seas)+ s(flow_acc_log, k=k,by=col_seas) + skua50_yn*col_seas+s(subcol, bs="re"),select=TRUE, data=all_dat_mod, method="ML")

summary(cr_xcolseas2)

plot.gam(cr_xcolseas2,pages=3,shade=TRUE)
# k=8
# gam_cr_int1 <- gam(prod~s(area,k=k) + s(pa_ratio,k=k)+ s(pa_ratio, by=skua50_yn, k=k)+ ti(area, pa_ratio, k=k)+s(mean_slope, k=k)+ s(adjust_mean_elev,k=k) +s(mean_aspect, bs="cc", k=k) +s(mean_wind,k=k)+s(flood_risk_trans,k=k) + ti(flood_risk_trans, mean_slope, k=k)+skua50_yn+season+s(subcol, bs="re", k=k), data=all_dat_scale, select=TRUE, method="ML")


AICctab(cr_base,cr_xcol,cr_xseas,cr_xcolseas2,nobs=346, base=TRUE, weights=TRUE, logLik=TRUE)



```
Model figures
```{r model figs}

plot.gam(gam_c_int1, select=1,se=TRUE, scheme=1, shade=T, shade.col="lightblue", all.terms=TRUE, pch=19, cex=0.5, ylab="area",xlab="Area", seWithMean = TRUE)

```



Predict Breeding success to held out counts
```{r Predict BS}
library(raster)
library(Hmisc)
# fit model with unscaled data and "REML" for prediction
# gam_c_glob_pred <- gam(prod~s(pa_ratio)+s(adjust_mean_elev)+ s(mean_aspect, bs="cc") + s(mean_wind)+skua50_yn+season+s(subcol,k=k, bs="re"), data=c_dat_mod, method="REML")
# 
# gam_c_int1_pred <- gam(prod~s(pa_ratio)+s(adjust_mean_elev) +s(mean_wind)+ ti(flood_risk_trans, mean_slope)+skua50_yn+season+s(subcol, bs="re"), data=c_dat_mod, select=TRUE, method="REML")
# 
# gam_c_globalx_pred <- gam(prod~s(area,by=season,k=k)+ s(pa_ratio, by=season,k=k) +s(mean_slope, by=season,k=k)+s(adjust_mean_elev,by=season,k=k)+s(mean_aspect, by=season,k=k, bs="cc") + +s(mean_wind, by=season,k=k)+s(flood_risk_trans, by=season,k=k)+ skua50_yn*season + s(subcol, bs="re"), data=c_dat_mod, select=TRUE, method="REML")
# 
# summary(gam_c_int1_pred)
# plot.gam(gam_c_simp1_pred, shade=TRUE, pages=1, scale=0, residuals=TRUE)


# Predict to held out m subcol ####
c_dat_hold<- c_dat_hold%>%
  filter(!subcol=="n11")
c_pred_1 <- predict.gam(gam_c_int1_pred,newdata=c_dat_hold)

c_pred_2 <- predict.gam(gam_c_glob_pred,newdata=c_dat_hold)

c_pred_3 <- predict.gam(gam_c_globalx_pred,newdata=c_dat_hold)

rcorr(c_dat_hold$prod,c_pred_1)
rcorr(c_dat_hold$prod,c_pred_2)
rcorr(c_dat_hold$prod,c_pred_3)
plot(c_dat_hold$prod,c_pred_2)

# predict to M from previous years
m_dat_old <- c_ct_meas%>%
  dplyr::select(col,season,area_name, subcol,active_ct,prod,area,perim,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_elev,mean_wind,mean_solar,flood_risk,skua50,skua100)%>%
  mutate(season=factor(season),subcol=factor(subcol))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1213", "1314"),!prod=="NA"&!is.na(pa_ratio), subcol%in%m_index)%>%
  mutate(adjust_mean_aspect=ifelse(!is.na(mean_aspect)&mean_aspect>300,mean_aspect-360,mean_aspect), season="1415")

gam_c_gsimp_mpred <- predict(gam_c_simp1_pred, newdata=m_dat_old)
rcorr(scale(gam_c_gsimp_mpred), scale(m_dat_old$prod))

# this doesn't appear to work very well, perhaps because relationship is noisy and the range of data in M is small

# Predict to Royds from Croz
r_dat_pred <- all_dat_scale%>%
  filter(col=="royds")%>%
  mutate(subcol="m5", season="1415")

c_pred_r <- predict.gam(gam_c_global, exclude=c("subcol","season"), newdata=r_dat_pred)
rcorr(r_dat_pred$prod,c_pred_r)

cr_pred_r <- predict.gam(gam_cr_global, exclude=c("subcol","season"), newdata=r_dat_pred)
rcorr(r_dat_pred$prod,cr_pred_r)

cr_pred_c <- predict.gam(gam_cr_global, exclude=c("subcol","season"), newdata=c_dat_mod)
rcorr(c_dat_mod$prod,cr_pred_c)


```
Predict Productivity Spatially
```{r Predict prod to space}
# read in rasters to use for prediction
library(raster)
# format data for prediction
# calculate productivity anomaly but do not scale other variables
pred_dat <- all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod)
k=6
c_base_pred <- gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=10, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50+s(subcol, bs="re"), select=TRUE, data=filter(pred_dat,col=="croz"), method="REML")
summary(c_base_pred)
c_base_pred_val<- predict(c_base_pred)
plot(croz_ann_prod$prod_anom,c_base_pred_val)

rcorr(croz_ann_prod$prod_anom,c_base_pred_val)


# c_seasonx_pred <-  gam(prod~s(area, by=season,k=k)+ s(pa_ratio, by=season,k=k)+s(mean_slope, by=season,k=k)+s(adjust_mean_elev, by=season,k=k)+s(mean_aspect, by=season,k=k, bs="cc") +s(mean_windshelt, by=season,k=k)+s(flow_acc_log, by=season, k=k)+skua50*season+s(subcol,bs="re"), data=c_dat,select=TRUE, method="REML")
# plot(c_seasonx_pred,page=2, shade=TRUE)

# 
# c_base_pred <- gam(prod~s(area, k=k) + s(pa_ratio, k=k)+s(mean_slope, k=k)+s(adjust_mean_elev, k=k) +s(mean_aspect,k=k, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log, k=k)+skua50+season+s(subcol, bs="re"), data=c_dat, select=TRUE, method="ML")
# plot(c_base_pred, pages=1)
# 
# 
# cr_xcol_pred <- gam(prod~s(area, k=k, by=col)+s(pa_ratio, k=k, by=col)+ s(mean_slope,k=k,  by=col)+ s(adjust_mean_elev, k=k, by= col)+ s(mean_aspect,k=k, bs="cc", by=col)+ s(mean_windshelt, k=k,by= col) + s(flow_acc_log, k=k,by=col) + skua50_yn*col+ season*col+s(subcol, bs="re"),select=TRUE, data=all_dat, method="REML")

library(raster)
# Load in raster data sets
c_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_area_rast.tif")
ext<-extent(c_area)
# 
c_skua50m <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_skua50mbin_rast.tif")

c_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_pa_ratio_rast.tif"),ext)

c_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_aspect_corrected.tif"),ext)

c_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_slope_clip.tif"),ext)

c_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_elev_clip.tif"),ext)+47

c_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_windshelter300m.asc"),ext)

c_flow <-log(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_flowacc_snow.tif"),ext))

#c_flow[c_flow==-Inf]<-NA


croz_stack <- stack(c_area, c_skua50m, c_pa_ratio,c_aspect, c_slope,c_elev,c_windshelt, c_flow)
names(croz_stack)<-c("area","skua50","pa_ratio","mean_aspect","mean_slope","adjust_mean_elev","mean_windshelt","flow_acc_log1p")
# 
# #fxn to rescale cell values between 0 and 1
# rasterRescale<-function(r){
#   ((r-cellStats(r,"min"))/(cellStats(r,"max")-cellStats(r,"min")))
# }
#  
# #run the fxn
# r2<-rasterRescale(r1)

  


# season_1415 <- data.frame(season=factor('1415', levels=levels(c_dat$season)),subcol="b33")
# c_pred_1415 <-predict(croz_stack,c_seasonx_pred,const=season_1415, exclude="s(subcol)",type="response")
# plot(c_pred_1415)
# 
# 
# # predict to 1516
# season_1516 <- data.frame(season=factor('1516', levels=levels(c_dat$season)),subcol="b33")
# c_pred_1516 <- predict(croz_stack,c_seasonx_pred,const=season_1516, type="response",exclude="s(subcol)")
# plot(c_pred_1516)
# 
# 
# # predict to 1617
# season_1617 <- data.frame(season=factor('1617', levels=levels(c_dat$season)),subcol="b33")
# c_pred_1617 <- predict(croz_stack,c_seasonx_pred,const=season_1617, type="response")
# plot(c_pred_1617)
# 
# # predict to 1718
# season_1718 <-data.frame(season=factor('1718', levels=levels(c_dat$season)),subcol="m21")
# c_pred_1718 <- predict(croz_stack,c_seasonx_pred,const=season_1718, type="response")
# c_pred_1718_cent <- c_pred_1718-mean(getValues(c_pred_1718))
# 
# c_pred_mean<-mean(c_pred_1415,c_pred_1516,c_pred_1617,c_pred_1718, na.rm=TRUE)
# 
# library(colorRamps)
# par(mfrow=c(2,2))
# zlim=c(-0.5,0.5)
# col=matlab.like(100)
# 
# rev(rainbow(99,start=0,end=0.8))
# col
# 
# plot(c_pred_1415-mean(getValues(c_pred_1415), na.rm=TRUE),col=col,zlim=zlim, main="1415")
# 
# plot(c_pred_1516-mean(getValues(c_pred_1516), na.rm=TRUE), col=col,zlim=zlim, main="1516")
# 
# plot(c_pred_1617-mean(getValues(c_pred_1617), na.rm=TRUE), col=col,zlim=zlim, main="1617")
# 
# plot(c_pred_1718-mean(getValues(c_pred_1718), na.rm=TRUE), col=col,zlim=zlim, main="1718")
# 
# 
# par(mfrow=c(1,1))
# plot(c_pred_mean-mean(getValues(c_pred_mean), na.rm=TRUE),col=col, zlim=zlim, main="Mean predicted productivity anomaly (1415-1718)")
# 
# 
# 
# plot(c_pred_1516, col=rainbow(99,start=0,end=0.8),zlim=c(0.4,1.7),main="1516")
# plot(c_pred_1617, col=rainbow(99,start=0,end=0.8),zlim=c(0.4,1.7), main="1617")
# plot(c_pred_1718, col=rainbow(99,start=0,end=0.8),zlim=c(0.4,1.7), main="1718")
# 
# plot(c_pred_mean)
# hist(c_pred_mean)
# 
# length(Which(c_pred_mean >= 1, cells = TRUE))/length(Which(c_pred_mean, cells = TRUE))
# 
#  13555/


c_pred_anom <- predict(croz_stack,c_base_pred, const=data.frame(subcol="m21"), exclude="s(subcol)", type="response")

plot(c_pred_anom)
hist(c_pred_anom)
mean(c_pred_anom@data@values, na.rm=TRUE)
writeRaster(c_pred_anom, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_prod_base_anom.tif", format="GTiff", overwrite=TRUE)


# read in table with bqi and nearest predicted prod
bqi_pred_prod <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/tables/croz_bqi_pred_prod_join2.txt")
library(Hmisc)

rcorr(bqi_pred_prod$BQI_A, bqi_pred_prod$grid_code)

# low BQI only
low_bqi <- bqi_pred_prod%>%
  filter(BQI_A<0)
rcorr(low_bqi$BQI_A, low_bqi$grid_code)


high_bqi <- bqi_pred_prod%>%
  filter(BQI_A>0)
rcorr(high_bqi$BQI_A, high_bqi$grid_code)


ggplot(bqi_pred_prod, aes(BQI_A, grid_code))+
         geom_point()+
  geom_smooth(method="lm")

m=lm(BQI_A~grid_code, data=bqi_pred_prod)
summary(m)
anova(m)

abline(bqi_pred_prod$BQI_A, bqi_pred_prod$grid_code)


# convert predicted prod raster to points
c_pred_anom_points<- rasterToPoints(c_pred_anom)
plot(c_pred_anom_points)


####################### Predict from Combined model
# season_1415 <- data.frame(season=factor('1415', levels=levels(c_dat$season)),subcol="b33")
# c_pred_1415 <-predict(croz_stack,c_seasonx_pred,const=season_1415, exclude="s(subcol)",type="response")
# plot(c_pred_1415)
# 
# 
# # predict to 1516
# season_1516 <- data.frame(season=factor('1516', levels=levels(c_dat$season)),subcol="b33")
# c_pred_1516 <- predict(croz_stack,c_seasonx_pred,const=season_1516, type="response",exclude="s(subcol)")
# plot(c_pred_1516)
# 
# 
# # predict to 1617
# season_1617 <- data.frame(season=factor('1617', levels=levels(c_dat$season)),subcol="b33")
# c_pred_1617 <- predict(croz_stack,c_seasonx_pred,const=season_1617, type="response")
# plot(c_pred_1617)
# 
# # predict to 1718
# season_1718 <-data.frame(season=factor('1718', levels=levels(c_dat$season)),subcol="m21")
# c_pred_1718 <- predict(croz_stack,c_seasonx_pred,const=season_1718, type="response")
# c_pred_1718_cent <- c_pred_1718-mean(getValues(c_pred_1718))
# 
# c_pred_mean<-mean(c_pred_1415,c_pred_1516,c_pred_1617,c_pred_1718, na.rm=TRUE)
# 
# library(colorRamps)
# par(mfrow=c(2,2))
# zlim=c(-0.5,0.5)
# col=matlab.like(100)
# 
# rev(rainbow(99,start=0,end=0.8))
# col
# 
# plot(c_pred_1415-mean(getValues(c_pred_1415), na.rm=TRUE),col=col,zlim=zlim, main="1415")
# 
# plot(c_pred_1516-mean(getValues(c_pred_1516), na.rm=TRUE), col=col,zlim=zlim, main="1516")
# 
# plot(c_pred_1617-mean(getValues(c_pred_1617), na.rm=TRUE), col=col,zlim=zlim, main="1617")
# 
# plot(c_pred_1718-mean(getValues(c_pred_1718), na.rm=TRUE), col=col,zlim=zlim, main="1718")
# 
# 
# par(mfrow=c(1,1))
# plot(c_pred_mean-mean(getValues(c_pred_mean), na.rm=TRUE),col=col, zlim=zlim, main="Mean predicted productivity anomaly (1415-1718)")
# 
# 
# 
# plot(c_pred_1516, col=rainbow(99,start=0,end=0.8),zlim=c(0.4,1.7),main="1516")
# plot(c_pred_1617, col=rainbow(99,start=0,end=0.8),zlim=c(0.4,1.7), main="1617")
# plot(c_pred_1718, col=rainbow(99,start=0,end=0.8),zlim=c(0.4,1.7), main="1718")
# 
# plot(c_pred_mean)
# hist(c_pred_mean)
# 
# length(Which(c_pred_mean >= 1, cells = TRUE))/length(Which(c_pred_mean, cells = TRUE))
# 
#  13555/
# 
# const=data
# c_pred_b <- predict(croz_stack,c_base_pred, const=data.frame(season="1516", subcol="b33"), exclude="s(subcol)", type="response")
# 
# plot(c_pred_mean-c_pred_b)
# 



#preparing raster object to plot with geom_tile in ggplot2

# 
# #preparing raster object to plot with geom_tile in ggplot2
# c_1415_ppts = rasterToPoints(c_pred_1415)
# c_1415_p_df = data.frame(c_1415_ppts)
# head(c_1415_p_df) #breaks will be set to column "layer"
# c_1415_p_df$cuts=cut(c_1415_p_df$layer,breaks=seq(0.2, 1.7, by=0.1)) #set breaks
# 
# p_1415<- ggplot(data=c_1415_p_df) + 
#   geom_tile(aes(x=x,y=y,fill=cuts)) + 
#   coord_equal() +
#   theme(panel.grid.major = element_blank()) +
#   xlab("Longitude") + ylab("Latitude")
# 
# 
# c_1516_ppts = rasterToPoints(c_pred_1516)
# c_1516_p_df = data.frame(c_1516_ppts)
# head(c_1516_p_df) #breaks will be set to column "layer"
# c_1516_p_df$cuts=cut(c_1516_p_df$layer,breaks=seq(0.2, 1.7, by=0.1)) #set breaks
# 
# p_1516<- ggplot(data=c_1516_p_df) + 
#   geom_tile(aes(x=x,y=y,fill=cuts)) + 
#   coord_equal() +
#   theme(panel.grid.major = element_blank()) +
#   xlab("Longitude") + ylab("Latitude")
# 
# 
# #preparing raster object to plot with geom_tile in ggplot2
# c_1617_ppts = rasterToPoints(c_pred_1617)
# c_1617_p_df = data.frame(c_1617_ppts)
# head(c_1617_p_df) #breaks will be set to column "layer"
# c_1617_p_df$cuts=cut(c_1617_p_df$layer,breaks=seq(0.2, 1.7, by=0.1)) #set breaks
# 
# p_1617<- ggplot(data=c_1617_p_df) + 
#   geom_tile(aes(x=x,y=y,fill=cuts)) + 
#   coord_equal() +
#   theme(panel.grid.major = element_blank()) +
#   xlab("Longitude") + ylab("Latitude")
# 
# 
# #preparing raster object to plot with geom_tile in ggplot2
# c_1718_ppts = rasterToPoints(c_pred_1718)
# c_1718_p_df = data.frame(c_1718_ppts)
# head(c_1718_p_df) #breaks will be set to column "layer"
# c_1718_p_df$cuts=cut(c_1718_p_df$layer,breaks=seq(0.2, 1.7, by=0.1)) #set breaks
# 
# p_1718<- ggplot(data=c_1718_p_df) + 
#   geom_tile(aes(x=x,y=y,fill=cuts)) + 
#   coord_equal() +
#   theme(panel.grid.major = element_blank()) +
#   xlab("Longitude") + ylab("Latitude")
# 
# grid.arrange(grobs=list(p_1415,p_1516,p_1617,p_1718), nrow=2)


# predict to available habitat ####

# read in layer with available habitat
c_avail <-  raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack_unoccupied/c_avail_hab_2014.tif")
plot(c_avail)
getValues(c_avail,400)

ext_avail <- extent(c_avail)

# make layer with constant pa_ratio
c_pa_ratio_avail <- c_avail
c_pa_ratio_avail[c_pa_ratio_avail==1]<-3

plot(c_pa_ratio_avail)
c_pa_ratio_avail[400,]
# read in raster layer with dist to skua
c_skua50m_avail <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack_unoccupied/skua50m_dist_rast_bin.tif"), ext_avail)
# replace NA with 0
c_skua50m_avail[is.na(c_skua50m_avail)]<-0
head(c_skua50m_avail[is.na(c_skua50m_avail)])
plot(c_skua50m_avail)

# mask other layers to match
#c_slope_avail <- crop(c_slope,ext_avail)
c_skua50m_avail<- mask(c_skua50m_avail, c_avail)
c_slope_avail <- mask(c_slope,c_avail)
c_elev_avail <- mask(c_elev, c_avail)
c_wind_avail <- mask(c_wind, c_avail)


c_stack_avail <- stack(c_pa_ratio_avail,c_skua50m_avail, c_slope_avail,c_elev_avail,c_wind_avail)
names(c_stack_avail)<-c("pa_ratio","skua50","mean_slope", "adjust_mean_elev","mean_wind")

season <- factor('1415', levels=levels(c_dat$season))
subcol <- factor("b33",levels=levels(c_dat$subcol))
add_avail<- data.frame(season, subcol)

c_pred_avail <- predict(c_stack_avail,gam_c_simp1_pred,const=add_avail, type="response")
c_pred_avail_scale <- scale(c_pred_avail)
plot(c_pred_avail)

writeRaster(c_pred_avail_scale, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_prod_avail_scale4.tif", format="GTiff", overwrite=TRUE)



t <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/tables/croz_bqi_pred_prod_test.txt", header=TRUE)

t<- t%>%
  mutate(RASTERVALU=ifelse(RASTERVALU==-9999,NA,RASTERVALU))%>%
  filter(Season_yr>2011)
rcorr(t$BQI_A, t$RASTERVALU)
dat10 <- c_dat%>%
  dplyr::select(subcol,prod)

t <- rename(t,subcol_anom=SELECTED_SUBCOL_)
t2 <- left_join(t,subcol_anom,by="subcol")
Hmisc::rcorr(t2$MEAN,t2$ann_prod_anom)
```

Predict at Cape Royds
```{r Predict for Cape Royds}

# Re-run model with unscaled variables for predicting
k=5
r_base_pred <- gam(prod~s(area, k=k)+s(pa_ratio,k=k)+s(mean_slope, k=k)+s(adjust_mean_elev, k=k)+s(mean_aspect,k=k, bs="cc")+ s(mean_windshelt,k=k)+ s(flow_acc_log,k=k)+s(subcol,bs="re")+season, data=r_dat,select=TRUE, method="REML")

summary(r_base_pred)
plot(r_base_pred)

r_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_area_rast.tif")
r_ext<-extent(r_flow)
plot(r_area)

r_skua50m <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_skua50m_bin.tif"),r_ext)
plot(r_skua50m)

r_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_pa_ratio_rast.tif"),r_ext)
plot(r_pa_ratio)

r_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_aspect_corrected.tif"),r_ext)
plot(r_aspect)

r_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_slope"),r_ext)
plot(r_slope)

r_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_mosaic_dem-tile-0_clip.tif"),r_ext)+47
plot(r_elev)


r_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_windshelter100m2.asc"),r_ext)
plot(r_windshelt)

r_flow <-log(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royd_flow_acc.tif"),r_ext))

r_flow[r_flow < 0] <-NA
plot(r_flow)

royds_stack <- stack(r_area,r_pa_ratio,r_skua50m, r_slope,r_aspect,r_elev,r_flow,r_windshelt)

names(royds_stack)<-c("area","pa_ratio","skua50","mean_slope", "mean_aspect","adjust_mean_elev","flow_acc_log","mean_windshelt")


r_1415 <- data.frame(season=factor('1415'),subcol="13")
r_pred_1415 <-predict(royds_stack,r_base_pred,const=r_1415, exclude="s(subcol)",type="response")

length(Which(r_pred_1415 >= 1, cells = TRUE))
length(Which(r_pred_1415 < 1, cells = TRUE))
54/(295+54)
# %15.5 percent low quality
r_pred_g1 <- reclassify(r_pred_1415,c(1,1,))
plot(r_pred_1415)

```