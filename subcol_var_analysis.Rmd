---
title: "Analysis of variation in reproductive success by subcolony"
author: "Annie Schmidt"
date: "June 2, 2016"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

```{r load libraries and data}

list.of.packages <- c("tidyverse", "mgcv","Hmisc", "stringr","gridExtra","veridis")
# compare to existing packages
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
# install missing packages
if(length(new.packages)>0) {install.packages(new.packages)}
# load required packages
lapply(list.of.packages, library, character.only = TRUE)

#Set working directory
# setwd("Z:/Informatics/S031/analyses/aschmidt/subcol_var")

  
# Define functions #### 
# correlation matrix of data
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- cor(x, y, use="complete.obs")
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * abs(r))
}


# read in count data files with subcolony attributes (created by croz(royd)_subcol_ct_data_prep.R) ####
# Crozier
c_ct_meas <- read_csv("data/croz_selected_meas_ct_all_v16.csv")

# Royds
r_ct_meas <- read_csv("data/royds_selected_meas_ct_all_v9.csv")


```

Format data for modeling
```{r format data, echo = FALSE}
# select columns for analysis
# create index of m subcolonies to hold out of analysis 
# have a disproportionate number from area M which is where most of the KA birds are
# so holding out some of the M subcolonies to predict to and correlate prediction with BQI would be good?

c_dat <- c_ct_meas%>%
  dplyr::select(-FID,-mean_elev, -perim)%>%
  mutate(season=factor(season),subcol=factor(subcol), m=ifelse(area_name=="m","y","n"), skua50_yn=factor(ifelse(skua50==1,"y","n")),skua50=factor(skua50), mean_acr=ifelse(mean_acr>2.02,NA,mean_acr),mean_acr_log=log(mean_acr))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1415","1516","1617","1718"),!subcol=="s3",!prod=="NA"&!is.na(pa_ratio))%>%
  dplyr::rename(mean_windshelt=mean_windshelt300m)

# Format Royds data
r_dat <- r_ct_meas%>%
  dplyr::select(-FID,-perimeter,-mean_elev)%>%
  mutate(season=factor(season),subcol=factor(subcol),col=factor(col),skua50_yn=factor(ifelse(skua50==1,"y","n")),skua50=factor(skua50),area_name=as.character(area_name))%>%
  # active count from 13 in 1617 looks off, exclude
  filter(!is.na(active_ct), !active_ct==0,!(subcol=="13"&season=="1617"))%>%
  dplyr::rename(mean_windshelt=mean_windshelt300m)
  
# one slope value for Royds 1b seems off (unlikely it's a 50deg slope)
# Setting it to value from other overpalling pixel = Pixel value	25.368334
# setting slope or 1b to value for other pixel that overlaps (more reasonable)
r_dat[r_dat$subcol=="1b","mean_slope"]=25.3683
# crazy slope causes other variables to be off also, need to reset these also to next pixel
# Flow acc change to 0
r_dat[r_dat$subcol=="1b","flow_acc"]=0
r_dat[r_dat$subcol=="1b","flow_acc_log1p"]=log1p(0)
# # wind shelt to -0.016
# windshelt 300m 2pi = 0.0262
# windshelt 300m 14pi8 = 0.1538
r_dat[r_dat$subcol=="1b","mean_windshelt"]=0.0262
# aspect to 253.100
r_dat[r_dat$subcol=="1b","mean_aspect"]=253.100
# elevation to -45.248047+47
r_dat[r_dat$subcol=="1b","adjust_mean_elev"]=-45.248047+46

# data.frame(filter(r_dat,subcol=="1b"))


# Combine data
all_dat <- c_dat%>%
  full_join(r_dat)%>%
  mutate(subcol=as.factor(subcol), col=as.factor(col),skua50_yn=factor(skua50_yn), season=factor(season))

# scale all data to make model fitting easier
all_dat_scale <- all_dat%>%
  mutate_at(vars(active_ct,prod,area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,flow_acc,flow_acc_log1p),funs(as.numeric))%>%
  mutate_at(vars(active_ct,prod,area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,flow_acc,flow_acc_log1p,mean_acr, mean_acr_log),funs(scale))


```            

Data vis
```{r figs}

pairs(c_dat[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)



# Color for Crozier
col1="#006C84" 
col2="#B2DBD5" # arctic
col3="#5EA8A7" # lagoon


# Subcol attr distributions fig ####
# melt data for data vis
subcol_attr <- all_dat%>%
  dplyr::select(-flood_risk,-active_ct,-ch_ct,-prod, -skua50_yn,-flow_acc_log,-mean_windshelt100m,-mean_acr,-mean_acr_log,-flow_acc)%>%
  # dplyr::slice(1)%>%
  gather(attr,value=measurement,-col,-season,-area_name,-subcol)%>%
  mutate(measurement=as.numeric(measurement),attr=factor(attr, labels=c("Elevation","Area","Flow accumulation","AreaM","Aspect","Slope","Wind shelter","Perim/Area ratio","Skua 50m")))%>%
  filter(!is.na(measurement))

# label panels with significant difference
attr_sig <- data.frame(attr=factor(c("Elevation","Area","Flow accumulation","Aspect","Slope","Wind shelter","Perim/Area ratio"), levels=c("Elevation","Area","Flow accumulation","AreaM","Aspect","Slope","Wind shelter","Perim/Area ratio")), sig=as.character(c("*","*","*","*","","*","*")))

subcol_attr%>%
  group_by(subcol,attr)%>%
  dplyr::slice(1)%>%
  filter(!attr=="Skua 50m")%>%
ggplot(aes(attr,measurement, fill=col,color=col))+
  # geom_histogram(bins=20, colour="white")+
  facet_wrap(~attr,scales="free", strip.position = "bottom")+
    geom_boxplot(width=0.5,alpha = 0.7)+
  # geom_hist(subset=.(attr=="Skua 50m"), bins=2)+
  ylab("Measurement")+
  xlab("")+
  # scale_fill_viridis(discrete=TRUE)+
  scale_color_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  guides(fill=guide_legend(title="Colony"),color=guide_legend(title="Colony"))+
  theme_classic()+
  theme(strip.placement.x = "outside",
    strip.background = element_blank(),
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), panel.border=element_blank(),axis.line= element_line(colour = "black"),axis.text.x=element_blank())+
  guides(fill=guide_legend(title="Colony"))+
  geom_text(data=attr_sig,aes(label=sig),show.legend=FALSE, x=Inf,y=Inf,hjust = 3,
    vjust = 1.5,size=8,inherit.aes = FALSE)

# Note, added skua panel separately in illustrator because couldn't figure out how to do it easily in R
  
# Tests for differences between the two colonies

pair_dat <-subcol_attr%>%
  group_by(subcol,attr)%>%
  dplyr::slice(1)%>%
  # filter(!attr=="Skua 50m")%>%
  spread(attr,measurement)

pair_dat%>%
  group_by(col)%>%
  summarise(t.stat=t.test(Elevation)$statistic)

c_dat$prod[c_dat$area_name=="m"]
# Most variables not normal so used Mann-Whitney U test
wilcox.test(pair_dat$Elevation[pair_dat$col=="croz"],pair_dat$Elevation[pair_dat$col=="royds"])
wilcox.test(pair_dat$Area[pair_dat$col=="croz"],pair_dat$Area[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Flow accumulation`[pair_dat$col=="croz"],pair_dat$`Flow accumulation`[pair_dat$col=="royds"])
wilcox.test(pair_dat$Aspect[pair_dat$col=="croz"],pair_dat$Aspect[pair_dat$col=="royds"])
wilcox.test(pair_dat$Slope[pair_dat$col=="croz"],pair_dat$Slope[pair_dat$col=="royds"]) # not significant
wilcox.test(pair_dat$`Wind shelter`[pair_dat$col=="croz"],pair_dat$`Wind shelter`[pair_dat$col=="royds"]) 
wilcox.test(pair_dat$`Perim/Area ratio`[pair_dat$col=="croz"],pair_dat$`Perim/Area ratio`[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Skua 50m` [pair_dat$col=="croz"],pair_dat$`Skua 50m`[pair_dat$col=="royds"])

mean(pair_dat$Aspect[pair_dat$col=="croz"])
mean(pair_dat$Aspect[pair_dat$col=="royds"])

# Test if proportion of subcol with skuas near is different
croz_skua<- sum(pair_dat$`Skua 50m`[pair_dat$col=="croz"])
n_croz<-length(pair_dat$`Skua 50m`[pair_dat$col=="croz"])
royds_skua <- sum(pair_dat$`Skua 50m`[pair_dat$col=="royds"])
n_royds <- length(pair_dat$`Skua 50m`[pair_dat$col=="royds"])

croz_skua/n_croz

prop.test(x=c(croz_skua,royds_skua),n=c(n_croz,n_royds))



# Croz and Royds productivity together ####
# Read in historic royds counts
r_ct_all <- read.csv("data/royds_all_ct_clean_thru1718.csv",header=TRUE)

cr_count_all <- c_ct_meas%>%
  full_join(r_ct_all)%>%
  dplyr::select(col,subcol,season,prod)%>%
  mutate(season=factor(season,labels=c("2002","2003","2004","2005","2006","2007","2008","2009","2010","2011","2012",
                                      "2013","2014","2015","2016","2017")))
#   # dplyr::slice(1)%>%
#   gather(subcol_attr,value=measurement,-col,-season,-area_name,-subcol)
# %>%
ggplot(cr_count_all,aes(season,prod, fill=col, color=col))+
  geom_boxplot(alpha = 0.7)+
  ylab("Breeding success (chicks/pair)")+
  xlab("Season")+
  # stat_summary(fun.y=mean, geom="point", 
  #              shape=19, size=3,show.legend = FALSE,position=position_dodge(width=0.7)) +
  scale_color_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  guides(fill=guide_legend(title="Colony"),color=guide_legend(title="Colony"))+
  theme_classic()

# Royds CV
r_cv_seas<-r_ct_all%>%
  group_by(season)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
mean(r_cv_seas$cv, na.rm=TRUE)
sd(r_cv_seas$mean,na.rm=TRUE)/mean(r_cv_seas$mean, na.rm=TRUE)
plot(r_cv_seas$season,r_cv_seas$cv,type="o", ylim=c(0,1))

r_cv_sub<-r_ct_all%>%
  group_by(subcol)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
mean(r_cv_sub$cv, na.rm=TRUE)
mean(r_ct_all$prod)
mean(r_cv_seas$mean)

sd(r_ct_all$prod)/mean(r_ct_all$prod)  
# Croz CV
c_cv_seas<-c_ct_meas%>%
  group_by(season)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
mean(c_cv_seas$cv, na.rm=TRUE)

par(mfrow=c(1,1))
lines(c_cv_seas$season,c_cv_seas$cv,type="o", lwd=2)

sd(c_cv_seas$mean,na.rm=TRUE)/mean(c_cv_seas$mean, na.rm=TRUE)
sd(c_ct_meas$prod,na.rm=TRUE)/mean(c_ct_meas$prod, na.rm=TRUE) 
mean(c_ct_meas$prod, na.rm=TRUE)
# SE of chicks per pair for whole time series
sd(c_ct_meas$prod,na.rm=TRUE)/sqrt(length(c_ct_meas$prod)-5) # 5 NA's
mean(c_dat$prod, na.rm=TRUE)
sd(c_dat$prod)/sqrt(length(c_dat$prod))

sd(r_ct_all$prod)/sqrt(length(r_ct_all$prod))

mean(r_dat$prod)
sd(r_dat$prod)/sqrt(length(r_dat$prod))

mean(c_dat$prod)
sd(c_dat$prod)/sqrt(length(c_dat$prod))

r_cv_seas_4<-r_ct_all%>%
  filter(season%in%c("1415","1516","1617","1718"))%>%
  group_by(season)%>%
  summarise(mean=mean(prod),sd=sd(prod))%>%
  mutate(cv=sd/mean)
mean(r_cv_seas_4$cv, na.rm=TRUE)

c_cv_seas_4<-c_ct_meas%>%
  filter(season%in%c("1415","1516","1617","1718"))%>%
  group_by(season)%>%
  summarise(mean=mean(prod),sd=sd(prod))%>%
  mutate(cv=sd/mean)
mean(c_cv_seas_4$cv, na.rm=TRUE)

```
Exploratory figs
```{r Explore data}
# Explore colinearity ####
pair_dat <-subcol_attr%>%
  group_by(subcol,attr)%>%
  dplyr::slice(1)%>%
  filter(!attr=="Skua 50m")%>%
  spread(attr,measurement)

c_dat_corr <- c_dat%>%
  group_by(subcol)%>%
  dplyr::slice(1)

r_dat_corr<- r_dat%>%
  group_by(subcol)%>%
  dplyr::slice(1)

pairs(c_dat_corr[,c("area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)


pairs(r_dat_corr[,c("area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)

####
ggplot(c_dat, aes(season,prod, fill=m))+
  geom_boxplot()

ggplot(c_dat, aes(m,prod, fill=m))+
  geom_boxplot()

c_dat%>%
  filter(season%in%c("1415","1516","1617","1718"))%>%
ggplot(aes(area_name,prod))+
  geom_boxplot(fill=col1)

# test mean productivity between m and other areas
t.test(c_dat$prod[c_dat$m=="y"],c_dat$prod[c_dat$m=="n"])
# test between M and area with highest mean (qr): not significant
t.test(c_dat$prod[c_dat$area_name=="m"],c_dat$prod[c_dat$area_name=="qr"])
# test between M and loweset mean (l): significant
t.test(c_dat$prod[c_dat$area_name=="m"],c_dat$prod[c_dat$area_name=="l"])
# test between highest (qr) and lowest (l): significant
names(t.test(c_dat$prod[c_dat$area_name=="qr"],c_dat$prod[c_dat$area_name=="l"]))


# M time series plot
c_ct_meas%>%
  mutate(season=factor(season), m_not=ifelse(area_name=="m","m","other"))%>%
  ggplot(aes(season,prod, fill=m_not))+
  geom_boxplot()



# plot ave by subcol
sub4 <- c_dat%>%
  dplyr::select(subcol,prod)%>%
  group_by(subcol)%>%
  summarise(count=n())%>%
  filter(count==4)

n_subcol_cts <- c_ct_meas%>%
  filter(area_name=="m")%>%
  group_by(subcol)%>%
  summarise(count=n())%>%
  filter(count>=10)

c_dat%>%
  dplyr::select(season,prod)%>%
  group_by(season)%>%
  summarise(count=n())
r_dat%>%
  dplyr::select(season,prod)%>%
  group_by(season)%>%
  summarise(count=n())


  #annotate("text", x = 1:length(n_subcol_cts$subcol),y =1.65, label = n_subcol_cts$n, col="blue") + 
  #labs(y = "chicks per active nest")

# Plot prod by subcol
c_dat%>%
  # filter(subcol%in%sub4$subcol)%>%
  ggplot(aes(subcol,prod)) + 
  geom_boxplot(fill="lavender") 

# Two panel plot with m timeseries and subcols with 4 counts
p_sub4_box <-c_dat%>%
  filter(subcol%in%sub4$subcol)%>%
  ggplot(aes(area_name,prod)) + 
  geom_boxplot(fill="coral") 
p_m_box <- c_ct_meas%>%
  mutate(season=factor(season), m_not=ifelse(area_name=="m","m","other"))%>%
  ggplot(aes(season,prod))+
  geom_boxplot(fill=col1)

grid.arrange(p_sub4_box,p_m_box)


c_ct_meas%>%
  filter(area_name=="m", !subcol=="mis")%>%
  full_join(n_subcol_cts)%>%
  ggplot(aes(subcol,prod)) + 
  geom_boxplot(fill=col1)+
  annotate("text", x = 1:length(n_subcol_cts$subcol),y =1.65, label = n_subcol_cts$count, col="blue") + 
  labs(y = "chicks per active nest")

c_ct_meas%>%
  filter(subcol%in%n_subcol_cts$subcol)%>%
  ggplot(aes(subcol,prod)) + 
  geom_boxplot() +
  annotate("text", x = 1:length(n_subcol_cts$subcol),y =1.65, label = n_subcol_cts$count, col="blue") + 
  labs(y = "chicks per active nest")

t.test(c_ct_meas$prod[c_ct_meas$subcol=="m5"],c_ct_meas$prod[c_ct_meas$subcol=="m30"])

# Plot variance in counts by subcol area

var_by_area <- c_dat%>%
  filter(subcol%in%sub4$subcol)%>%
  group_by(subcol)%>%
  summarise(var=var(prod),area=mean(area))

  ggplot(var_by_area,aes(area,var))+
  geom_point()+
    geom_smooth()
  
c_var_gam <- gam(var~s(area), data=var_by_area, method="ML")
summary(c_var_gam)
plot.gam(c_var_gam, shade=TRUE, residuals=TRUE, cex=2)
  
rcorr(var_by_area$area, var_by_area$var)




# Plot weather data ####
# Read in weather data 
wthr <- read.csv("data/weather_summary_1415-1718.csv", header=TRUE)%>%
  mutate(season=factor(season), DATE=as.Date(DATE),jdate=as.POSIXlt(DATE)$yday)%>%
  filter(jdate>333&jdate<=365)
wind_dir <- c("N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW")
spd <-30

# Plots of wind speed and direction ####

# Plot number of times each direction recorded
wthr%>%
  filter(!is.na(GUSTMPH))%>%
  group_by(season, DIR)%>%
  summarise(perc_days=n()/nrow(.))%>%
dplyr::slice(match(wind_dir,DIR))%>%
  ggplot(aes(DIR, perc_days))+
  geom_bar(stat="identity")+
  facet_wrap(~season, nrow=4)

# Plot direction of high wind events
hwe<- wthr%>%
  filter(GUSTMPH>spd)%>%
  group_by(season)%>%
  summarise(nobs=n())%>%
  ggplot(aes(season,nobs))+
  geom_bar(stat="identity")+
  ylab("High Wind Events \n(# obs of >30mph)")


# Plot of temperature
p_temp<-wthr%>%
  group_by(DATE)%>%
  arrange(LOWTEMP)%>%
  dplyr::slice(1)%>%
  group_by(season)%>%
  summarise(mean_lowtemp=mean(LOWTEMP, na.rm=TRUE),se=sd(LOWTEMP, na.rm=TRUE)/sqrt(n()))%>%
  ggplot(aes(season,mean_lowtemp))+
           geom_bar(stat="identity")+  
  geom_errorbar(aes(ymin=mean_lowtemp - se,ymax=mean_lowtemp+se), width=.2,
                position=position_dodge(.9))+
  xlab("Season")+
  ylab("Mean Low Temp (Dec)")
# +
#   guides(fill=guide_legend(title=NULL))+
#   scale_fill_manual(values=c("deeppink","seagreen3"),name=NULL,breaks=c("CL", "RL"),labels=c("Control Levee", "Restored Levee"))


temp <- wthr%>%
  group_by(DATE)%>%
  arrange(LOWTEMP)%>%
  dplyr::slice(1)%>%
  group_by(season)

t.test(temp$LOWTEMP[temp$season=="1415"],temp$LOWTEMP[temp$season=="1516"]) # significant
t.test(temp$LOWTEMP[temp$season=="1516"],temp$LOWTEMP[temp$season=="1617"])
t.test(temp$LOWTEMP[temp$season=="1617"],temp$LOWTEMP[temp$season=="1718"])
t.test(temp$LOWTEMP[temp$season=="1516"],temp$LOWTEMP[temp$season=="1718"])
t.test(temp$LOWTEMP[temp$season=="1415"],temp$LOWTEMP[temp$season=="1617"])
t.test(temp$LOWTEMP[temp$season=="1415"],temp$LOWTEMP[temp$season=="1718"]) # significant


# Number of observations with snow

snow_days <- wthr%>%
  filter(str_detect(NOTES, "snow|Snow|SNOW"))%>%
  group_by(season, DATE)%>%
  dplyr::slice(1)%>%
  group_by(season)%>%
  summarise(snow_days=n())%>%
  ggplot(aes(season,snow_days))+
  geom_bar(stat="identity")+
  xlab("Season")+
  ylab("Snow days")

mean_prod<-all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  ggplot(aes(season,mean_prod,fill=col))+
           geom_bar(stat="identity", position="dodge")+  
  geom_errorbar(aes(ymin=mean_prod - se,ymax=mean_prod+se), width=.2,
                position=position_dodge(.9))+
  xlab("Season")+
  ylab("Mean Productivity \n(chicks fledged per pair)")


var_prod<-all_dat%>%
  group_by(col,season)%>%
  summarise(var_prod=var(prod, na.rm=TRUE))%>%
  ggplot(aes(season,var_prod, fill=col))+
           geom_bar(stat="identity", position="dodge")+
  xlab("Season")+
  ylab("Variance in Productivity")


grid.arrange(grobs=list(mean_prod,hwe, p_temp), nrow=4)


plot(c_dat$mean_slope,c_dat$mean_TRI)
rcorr(c_dat$mean_slope,c_dat$mean_TRI)

```

Crozier GAMM
```{r Crozier GAMM}
# Starting with model with all variables of interest subcol id as random effect
# using REML based on recommendation in Marra and Wood 2011
# # Except if I want to compare models with different fixed effects I shouldn't
# # https://stats.stackexchange.com/questions/116770/reml-or-ml-to-compare-two-mixed-effects-models-with-differing-fixed-effects-but?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
# # thread suggests using REML because it does a better job with random effects on just your final model for inference and prediction

# remove annual mean so just modeling the spatial variability, not the annual variability
ann_prod_anom<-all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod)%>%
  mutate_at(vars(area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,flow_acc,flow_acc_log,flow_acc_log1p,mean_acr,mean_acr_log),funs(scale))
# plot(ann_prod_anom$subcol,ann_prod_anom$prod_anom)

# Set k=6
ck=6
c_base_anom <-gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")

# c_base_test <-gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
# summary(c_base_test)
# # plot.gam(c_base_test)

summary(c_base_anom)
anova(c_base_anom)
plot.gam(c_base_anom,pages=1, shade=TRUE)

gam.vcomp(c_base_anom)
par(mfrow=c(2,2))
gam.check(c_base_anom)
concurvity(c_base_anom, full=FALSE)


# # Refit model with REML 
# c_base_anom_REML <-gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+s(skua50, bs="fs",k=ck)+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="REML")
# summary(c_base_anom_REML)
# par(mfrow=c(2,2))
# gam.check(c_base_anom_REML)


ck=6
c_seasonx_anom <-gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev,by=season, k=ck)+s(mean_slope, by=season, k=ck) +s(mean_aspect,by=season,k=ck, bs="cc") +s(mean_windshelt,by=season,k=ck)+s(flow_acc_log1p,by=season, k=ck)+skua50*season+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
summary(c_seasonx_anom)
plot.gam(c_seasonx_anom,pages=1, shade=TRUE)


# check how compare
library(bbmle)
c_mod_tab<-AICctab(c_base_anom,c_seasonx_anom,nobs=292, base=TRUE, weights=TRUE, logLik=TRUE)


```

Gamms for Royds
```{r Royds Gamms, include=FALSE}

rk=4
r_base_anom <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="ML")
summary(r_base_anom)
plot.gam(r_base_anom, pages=1)

# rb_test <- gam(prod_anom~ s(pa_ratio, k=rk)+s(mean_slope,k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="ML")
# summary(rb_test)
# plot.gam(rb_test, pages=1, shade=T, residuals=T)

summary(r_base_anom)
plot.gam(r_base_anom, pages=1, shade=T, residuals=T)
gam.check(r_base_anom) # looks pretty good, some skew in the residuals

# r_base_anom_REML <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=3)+s(skua50,bs="fs")+s(subcol, bs="re"), data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="REML")
# summary(r_base_anom_REML)

# rk=3 # Can't fit this model with k=4 (Model has more coefficients than data), can with k=3 is this a good idea? Seems risky to put too much on so little data
r_seasonx_anom <-  gam(prod_anom~s(area,k=rk) + s(pa_ratio,k=rk)+ s(adjust_mean_elev,by=season, k=rk)+s(mean_slope,by=season,k=rk) +s(mean_aspect, by=season,bs="cc", k=rk) +s(mean_windshelt,by=season,k=rk)+ s(flow_acc_log1p,by=season,k=3)+ skua50*season, data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="ML")
summary(r_seasonx_anom)
plot(r_seasonx_anom, pages=2, shade=TRUE)

library(bbmle)
r_mod_tab<-AICctab(r_base_anom,r_seasonx_anom,nobs=86, base=TRUE, weights=TRUE, logLik=TRUE)

```
Proportion Deviance explained
```{r calculate proportion deviance explained}

# Calculate proportion deviance explained by each model
# Example fount here: http://r.789695.n4.nabble.com/variance-explained-by-each-term-in-a-GAM-td836513.html
# b <- gam(y~s(x1)+s(x2))
# > b1 <- gam(y~s(x1),sp=b$sp[1])
# > b2 <- gam(y~s(x2),sp=b$sp[2])
# > b0 <- gam(y~1)
# > ## calculate proportions deviance explained...
# > (deviance(b1)-deviance(b))/deviance(b0) ## prop explained by s(x2)
# > (deviance(b2)-deviance(b))/deviance(b0) ## prop explained by s(x1)

cb<-c_base_anom # Rename base model
# Fit intercept only model
cb0 <- gam(prod_anom~1, data=filter(ann_prod_anom,col=="croz"))

# Fit model with pa ratio removed and smooths for all other variables supplied from base model
# Area, aspect, and wind already dropped

# Drop pa ratio
cb1 <-gam(prod_anom~s(area, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE,method="ML", sp=c_base_anom$sp[-c(3,4)])

# Fit model with elevation removed
cb2 <-gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE,method="ML", sp=c_base_anom$sp[-c(5,6)])
# slope removed
cb3<- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE,method="ML",sp=c_base_anom$sp[-c(7,8)])
# Windshelter removed
# cb4 <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc")+s(flow_acc_log1p, k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE,method="ML", sp=c_base_anom$sp[-c(10,11)])
# flow accumulation removed
cb5 <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"),select=TRUE, method="ML", sp=c_base_anom$sp[-c(12,13)] )
#Skua removed
cb6 <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck), data=filter(ann_prod_anom,col=="croz"),select=TRUE, method="ML",sp=c_base_anom$sp[-14])
# # subcol ID removed
# cb7 <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="REML",sp=c_base_anom_REML$sp[-15])

summary(cb)$dev.expl-summary(cb1)$dev.expl

cst=cb0
cov = cb1
t=cb

c_pa_devex <- 1-(deviance(cb0)-deviance(cb1))/(deviance(cb0)-deviance(cb))
c_elev_devex <- 1-(deviance(cb0)-deviance(cb2))/(deviance(cb0)-deviance(cb))
c_slope_devex <-1-(deviance(cb0)-deviance(cb3))/(deviance(cb0)-deviance(cb))
# c_wind_devex <-1-(deviance(cb0)-deviance(cb4))/(deviance(cb0)-deviance(cb))
c_flood_devex<-1-(deviance(cb0)-deviance(cb5))/(deviance(cb0)-deviance(cb))
c_skua_devex<-1-(deviance(cb0)-deviance(cb6))/(deviance(cb0)-deviance(cb))


# Croz Proportion (deviance(rb1)-deviance(rb))/deviance(rb0)

c_pa_ndevex <- (deviance(cb1)-deviance(cb))/deviance(cb0)
c_elev_ndevex <- (deviance(cb2)-deviance(cb))/deviance(cb0)
c_slope_ndevex <- (deviance(cb3)-deviance(cb))/deviance(cb0)
# c_wind_devex <- (deviance(cb4)-deviance(cb))/deviance(cb0)
c_flood_ndevex<- (deviance(cb5)-deviance(cb))/deviance(cb0)
c_skua_ndevex<- (deviance(cb6)-deviance(cb))/deviance(cb0)
# c_subcol_devex<- (deviance(cb7)-deviance(cb))/deviance(cb0)


# Royds
rb <- r_base_anom
rb0 <- gam(prod_anom~1, data=filter(ann_prod_anom,col=="royds"))
deviance(rb0)
rb$sp[c(1)]

t <- gam.vcomp(rb)

# Elevation dropped already

#pa ratio removed
rb1 <-gam(prod_anom~ s(area, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"),select=TRUE,method="ML", sp=rb$sp[-c(3,4)])
summary(rb1)

# Fit model with slope removed
rb2 <-gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+ s(adjust_mean_elev, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML", sp=rb$sp[-c(7,8)])
# Aspect removed
rb3 <-gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+ s(adjust_mean_elev, k=rk) +s(mean_slope, k=rk) +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML", sp=rb$sp[-9])
# Windshelter removed
rb4<- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk) +s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc")+s(flow_acc_log1p, k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML",sp=rb$sp[-c(10,11)])

# flow accumulation removed
rb5 <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+skua50, data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML", sp=rb$sp[-c(12,13)] )
#Skua removed
rb6 <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk), data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML",sp=rb$sp[-14])
# area removed
rb7 <- gam(prod_anom~s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk), data=filter(ann_prod_anom,col=="royds"),select=TRUE, method="ML",sp=rb$sp[-c(1,2)])

# # subcol ID removed
# rb9 <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+s(skua50, bs="fs",k=rk), data=filter(ann_prod_anom,col=="royds"), select=TRUE,method="REML",sp=rb$sp[-15])
# summary(rb9)
# 
# rb_test <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk) +s(mean_slope,k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+s(skua50,bs="fs",k=rk), data=filter(ann_prod_anom,col=="royds"), select=TRUE, method="REML")
# summary(rb_test)
# plot.gam(rb_test)

# Proportion deviance explained
summary(rb)$dev.expl-summary(rb0)$dev.expl
summary(rb)$dev.expl-summary(rb1)$dev.expl
summary(rb)$dev.expl-summary(rb2)$dev.expl

summary(rb)$dev.expl-(1-deviance(rb6)/rb6$null.deviance)

r_pa_devex <- 1-(deviance(rb0)-deviance(rb1))/(deviance(rb0)-deviance(rb))
r_slope_devex <- 1-(deviance(rb0)-deviance(rb2))/(deviance(rb0)-deviance(rb))
r_aspect_devex <- 1-(deviance(rb0)-deviance(rb3))/(deviance(rb0)-deviance(rb))
r_windshelt_devex <- 1-(deviance(rb0)-deviance(rb4))/(deviance(rb0)-deviance(rb))
r_flood_devex<- 1-(deviance(rb0)-deviance(rb5))/(deviance(rb0)-deviance(rb))
r_skua_devex<- 1-(deviance(rb0)-deviance(rb6))/(deviance(rb0)-deviance(rb))
r_area_devex <- 1-(deviance(rb0)-deviance(rb7))/(deviance(rb0)-deviance(rb))

r_pa_ndevex <- (deviance(rb1)-deviance(rb))/deviance(rb0)
r_slope_ndevex <- (deviance(rb2)-deviance(rb))/deviance(rb0)
r_aspect_ndevex <- (deviance(rb3)-deviance(rb))/deviance(rb0)
r_windshelt_ndevex <- (deviance(rb4)-deviance(rb))/deviance(rb0)
r_flood_ndevex<- (deviance(rb5)-deviance(rb))/deviance(rb0)
r_skua_ndevex<- (deviance(rb6)-deviance(rb))/deviance(rb0)
r_area_ndevex <- (deviance(rb7)-deviance(rb))/deviance(rb0)

# Make table to proportion deviance explained
rb_term_devex<-c(r_area_devex,r_pa_devex,0,r_slope_devex,r_aspect_devex,r_windshelt_devex,r_flood_devex,r_skua_devex)
sum(rb_term_devex)
rb_term_ndevex <- c(r_area_ndevex,r_pa_ndevex,0,r_slope_ndevex,r_aspect_ndevex,r_windshelt_ndevex,r_flood_ndevex,r_skua_ndevex)
sum(rb_term_ndevex)

cb_term_devex<- c(0,c_pa_devex,c_elev_devex, c_slope_devex,0,0, c_flood_devex, c_skua_devex)
sum(cb_term_devex)

cb_term_ndevex<- c(0,c_pa_ndevex,c_elev_ndevex, c_slope_ndevex,0,0, c_flood_ndevex, c_skua_ndevex)
sum(cb_term_ndevex)

term_devex <- data.frame(term=c("Area","Perim/area_ratio","Elevation","Slope","Aspect","Wind_shelter", "flow_acc","skua"), Croz_ndevex=cb_term_ndevex, Croz_mdevex=cb_term_devex,Royds_ndevex=rb_term_ndevex,royds_mdevex=rb_term_devex)

# write.csv(term_devex,"Z:/Informatics/S031/analyses/aschmidt/subcol_var/results/gam_model_term_deviance_explained_v5.csv")
# 
(deviance(rb0)-deviance(rb1))/(deviance(rb0)-deviance(rb))
(deviance(rb0)-deviance(rb2))/(deviance(rb0)-deviance(rb))
# (deviance(rb0)-deviance(rb3))/(deviance(rb0)-deviance(rb))
# (deviance(rb0)-deviance(rb4))/(deviance(rb0)-deviance(rb))
# (deviance(rb0)-deviance(rb5))/(deviance(rb0)-deviance(rb))
# (deviance(rb0)-deviance(rb6))/(deviance(rb0)-deviance(rb))



```

Model figures
```{r model figs}

croz_ann_prod <- filter(ann_prod_anom,col=="croz")%>%
  mutate(predict_base=predict(c_base_anom))

royds_ann_prod <- filter(ann_prod_anom,col=="royds")%>%
  mutate(predict_base=predict(r_base_anom))

ann_prod_pred<-croz_ann_prod%>%
  full_join(royds_ann_prod)
# c_obs_v_pred<-ggplot(croz_ann_prod,aes(prod_anom,predict_cbase))+
#   geom_point()+
#   geom_smooth(method="lm",colour="black")+
#   xlab("Observed breeding success")+
#   ylab("Predicted breeding success")+
#   theme_classic()

ggplot(ann_prod_pred,aes(prod_anom,predict_base, colour=col))+
  geom_point(aes(shape=col, color=col),size=2)+
  geom_smooth(method="lm",show.legend = FALSE,aes(fill=col),alpha=0.4)+
  geom_abline(slope=1, intercept=0)+
  xlab("Observed breeding success")+
  ylab("Predicted breeding success")+
  # scale_colour_manual(values=c("#FF3366","grey60"),name="Colony",labels = c("Crozier","Royds"))+
  scale_colour_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))+
  scale_shape(name="Colony",labels=c("Crozier","Royds"))+
  theme_classic()


# ggplot(bqi_pred_prod,aes(hab_qual,BQI_A, color=bqi_cat))+
#   geom_point()+geom_smooth(method=lm)+
#   xlab("Habitat quality")+
#   ylab("Breeding quality index (BQI)")+
#   # scale_colour_manual(values = c("Black", "lightgrey", "grey50"))
#   scale_colour_grey(labels = c("High","Medium","Low"))+
#   # theme_bw()+ 
#   guides(colour=guide_legend(title="BQI\ncategory"))+
#   theme_classic()
  
# c_ovp<-ggplot(croz_ann_prod,aes(prod_anom,predict_cbase_REML))+
#   geom_point()+
#    geom_smooth(method="lm",colour="black")+
#   xlab("Observed breeding success")+
#   ylab("Predicted breeding success")+
#   ylim(c(-0.7,0.7))+
#   xlim(c(-0.7,0.7))+
#   theme_classic()+
#   geom_text(x=-0.6, y=0.4, label="C. Crozier")
# print(c_ovp)

# 
rcorr(croz_ann_prod$prod_anom,croz_ann_prod$predict_base)
rcorr(royds_ann_prod$prod_anom,royds_ann_prod$predict_base)
# 
# 
# r_ovp<-ggplot(royds_ann_prod,aes(prod_anom,predict_base))+
#   geom_point()+
#    geom_smooth(method="lm",colour="black")+
#   xlab("Observed breeding success")+
#   ylab("Predicted breeding success")+
#   ylim(c(-0.7,0.7))+
#   xlim(c(-0.7,0.7))+
#   geom_text(x=-0.6, y=0.4, label="C. Royds")+
#   theme_classic()
# print(r_ovp)
# 
# grid.arrange(grobs=list(c_ovp,r_ovp), nrow=2)

# Model plots ####
pred_dat<- all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod, skua50=as.factor(skua50))

c_base_pred <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, select=TRUE, data=filter(pred_dat,col=="croz"), method="ML")

rk=4
r_base_pred <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+skua50, select=TRUE, data=filter(pred_dat,col=="royds"), method="ML")



# Need to do them one at a time to modify labels
# Croz and Royds side-by-side
par(mfrow=c(4,4),mar=c(3,4,2,1),mgp=c(2,0.7,0))
ylim=c(-1,0.45)
# Area ##
# Croz
plot.gam(c_base_pred,select=1, xlab="Area",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Crozier", shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=1, xlab="Area",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Royds", shade.col = alpha(col2,0.7),col=col3)

# PA ratio ##
# Croz
plot.gam(c_base_pred,select=2, xlab="Perim/Area ratio",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,main="Crozier",shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=2, xlab="Perim/Area ratio",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Royds",shade.col = alpha(col2,0.7),col=col3)

# Elevation ##
# Croz
plot.gam(c_base_pred,select=3, xlab="Elevation", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=3, xlab="Elevation", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Slope##
# Croz
plot.gam(c_base_pred,select=4, xlab="Slope", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=4, xlab="Slope", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Aspect
# Croz
plot.gam(c_base_pred,select=5, xlab="Aspect", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=5, xlab="Aspect", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Wind shelter
# Croz
plot.gam(c_base_pred,select=6, xlab="Wind shelter", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=6, xlab="Wind shelter", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Flow accumulation
# Croz
plot.gam(c_base_pred,select=7, xlab="Flow accumulation",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=7, xlab="Flow accumulation",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col="#5EA8A7")

# Skua
# Croz
termplot(c_base_pred, terms=c("skua50"), se=TRUE, col.term= col1, lwd.term=3, lwd.se=1,lty.se = 1,col.se=col1, use.factor.levels = TRUE, pch=19, ylab="Breeding success", xlab="Skua within 50m",ylim=ylim)
# Royds
termplot(r_base_pred, terms=c("skua50"), se=TRUE, col.term= col3, lwd.term=3, lwd.se=1,lty.se = 1,col.se=col3, use.factor.levels = TRUE, pch=19, ylab="Breeding success", xlab="Skua within 50m",ylim=ylim)



# gam1$coefficients["(Intercept)"]
# gam1$coefficients["season1516:col_sidew"]
# 
# termplot(gam1, terms=c("season"), se=TRUE, col.term= "black", lwd.term=4, lwd.se=2,col.se="black", use.factor.levels = TRUE, pch=19, ylab="Partial for season", xlab="Season",ylim=c(-1.7,0))
# 
# termplot(gam1, terms="season1516:col_sidew", se=TRUE, col.term= "black", lwd.term=4, lwd.se=2,col.se="black", use.factor.levels = TRUE, pch=19, ylab="Partial for colony side", xlab="colony side",ylim=c(-1.7,0))

# 
# # Royds gam plot
# # Need to do them one at a time to modify labels
# par(mfrow=c(3,3),mar=c(4,4,3,2))
# plot.gam(r_base_anom_REML,select=1, xlab="Area",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)
# 
# plot.gam(r_base_anom_REML,select=2, xlab="Perim/Area ratio",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)
# 
# plot.gam(r_base_anom_REML,select=3, xlab="Elevation", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)
# 
# plot.gam(r_base_anom_REML,select=4, xlab="Slope", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)
# 
# plot.gam(r_base_anom_REML,select=5, xlab="Aspect", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)
# 
# plot.gam(r_base_anom_REML,select=6, xlab="Wind shelter", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)
# 
# plot.gam(r_base_anom_REML,select=7, xlab="Flow accumulation",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3)

```

Predict Productivity Spatially
```{r Predict prod to space}
# read in rasters to use for prediction
library(raster)
# format data for prediction
# calculate productivity anomaly but do not scale other variables
pred_dat<- all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod, skua50=as.factor(skua50))
k=6
c_base_pred <- gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=k, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50, select=TRUE, data=filter(pred_dat,col=="croz"), method="ML")

plot(c_base_pred, pages=1)
summary(c_base_pred)
c_base_pred_val<- predict(c_base_pred)
plot(croz_ann_prod$prod_anom,c_base_pred_val)
cor(croz_ann_prod$prod_anom,c_base_pred_val)



# Load in raster data sets
# Need all variables even though some get dropped
library(raster)
c_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_area_rast.tif")
ext<-extent(c_area)
plot(c_area)
# 
# Need to change this to y n for model
c_skua50<-crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_skua50mbin_rast.tif"),ext)
plot(c_skua50)


c_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_pa_ratio_rast.tif"),ext)
plot(c_pa_ratio)

c_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_aspect_corrected.tif"),ext)
plot(c_aspect)

c_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_slope_clip.tif"),ext)
plot(c_slope)

c_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_elev_clip.tif"),ext)+47
plot(c_elev)

c_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_windshelter_300m_2pi_v2.asc"),ext)
plot(c_windshelt)

c_flow <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_flowacc_snow_v2.tif"),ext))
plot(c_flow)

# c_flow[c_flow==-Inf]<-NA


croz_stack <- stack(c_area, c_skua50, c_pa_ratio,c_aspect, c_slope,c_elev,c_windshelt, c_flow)
names(croz_stack)<-c("area","skua50","pa_ratio","mean_aspect","mean_slope","adjust_mean_elev","mean_windshelt","flow_acc_log1p")

# Predict to all subcolonies at Crozier
c_pred_anom <- predict(croz_stack,c_base_pred, type="response")

plot(c_pred_anom, col=rev(rainbow(50, start = 0, end = 0.8, alpha = 1)),main="Predicted habitat quality")
hist(c_pred_anom@data@values)
mean(c_pred_anom@data@values, na.rm=TRUE)
sd(c_pred_anom@data@values, na.rm=TRUE)/sqrt(sum(!is.na(c_pred_anom@data@values)))
# writeRaster(c_pred_anom, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_prod_base_anom_v10.tif", format="GTiff", overwrite=FALSE)
# 



# Correlate predicted prod/habitat quality with individual quality ####
# Use predicted prod layer in arc, convert to point layer, use spatial join to join predicted prod values to points where bqi birds bred

# # Or use extract function in raster package
# # read in bqi table
# bqi_last4seas<- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_last4seas_bqi_pred_prod_v2.csv",header=TRUE)




# read in table with bqi and nearest predicted prod
bqi_pred_prod <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_bqi_all_pred_prod_v5.csv")%>%
  filter(!GRID_CODE==0,Br_exp>2,Season%in%c(2014,2015,2016,2017),Orig_col=="CROZ",!Device==1,!Device=="GDR")%>%
  rename(hab_qual=GRID_CODE)%>%
  group_by(Bandnumb)%>%
  arrange(Season)%>%
  dplyr::slice(n())

bqi_pred_prod%>%
  summarise(n())

# min_bqi=min(bqi_pred_prod$BQI_A)
# range_bqi=max(bqi_pred_prod$BQI_A)-min(bqi_pred_prod$BQI_A)
# bqi_cuts=range_bqi/3
rcorr(bqi_pred_prod$BQI_A,bqi_pred_prod$hab_qual)

bqi_quant=quantile(bqi_pred_prod$BQI_A, probs = seq(0, 1, 0.25),na.rm=TRUE)
# low_break=bqi_pred_prod[58,"BQI_A"]
# mid_break=bqi_pred_prod[115,"BQI_A"]

bqi_pred_prod<- bqi_pred_prod%>%
  mutate(bqi_cat=ifelse(BQI_A<bqi_quant[2],"l",ifelse(BQI_A<bqi_quant[4],"m","h")))


ggplot(bqi_pred_prod,aes(BQI_A))+
  geom_histogram(bins=60)

# Overall correlation between BQI and predicted breeding success (habitat quality)
rcorr(bqi_pred_prod$BQI_A, bqi_pred_prod$hab_qual)

bqi_m <- lm(BQI_A~hab_qual*bqi_cat,data=bqi_pred_prod)
summary(bqi_m)
anova(bqi_m)

ggplot(bqi_pred_prod,aes(hab_qual,BQI_A))+
  geom_point()+geom_smooth(method=lm)+
  xlab("habitat quality")

# Scatter plot colored by bqi category
bqi_pred_prod$bqi_cat<- factor(bqi_pred_prod$bqi_cat, levels=c("h","m","l"))
bqi_pred_prod%>%
  group_by(bqi_cat)%>%
  summarise(mean_hq=mean(hab_qual))

ggplot(bqi_pred_prod,aes(hab_qual,BQI_A, color=bqi_cat))+
  geom_point(size=1.8)+geom_smooth(method=lm)+
  xlab("Habitat quality")+
  ylab("Breeding quality index (BQI)")+
  # scale_colour_manual(values = c("Black", "lightgrey", "grey50"))
  #scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9")
  scale_color_brewer(palette="Paired",labels = c("High","Medium","Low"))+
  # theme_bw()+ 
  guides(colour=guide_legend(title="BQI\ncategory"))+
  theme_classic()
  

ggplot(bqi_pred_prod,aes(hab_qual,BQI_A, color=Sex))+
  geom_point(size=1.8)+geom_smooth(method=lm)+
  xlab("Habitat quality")+
  ylab("Breeding quality index (BQI)")

rcorr(bqi_pred_prod$BQI_A[bqi_pred_prod$Sex=="F"], bqi_pred_prod$hab_qual[bqi_pred_prod$Sex=="F"])
m_bqi_sex<-lm(BQI_A~hab_qual*Sex,data=bqi_pred_prod)
anova(m_bqi_sex)
  
  # scale_colour_manual(values = c("Black", "lightgrey", "grey50"))
  #scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9")
  # scale_color_brewer(palette="Paired",labels = c("High","Medium","Low"))+
  # # theme_bw()+ 
  # guides(colour=guide_legend(title="BQI\ncategory"))+
  # theme_classic()


# low BQI only
low_bqi <- bqi_pred_prod%>%
  filter(bqi_cat=="l")
rcorr(low_bqi$BQI_A, low_bqi$hab_qual)

m_lbqi_hab_qual <- lm(BQI_A~hab_qual,data=low_bqi)
summary(m_lbqi_hab_qual)

# High quality birds only
high_bqi <- bqi_pred_prod%>%
  filter(bqi_cat=="h")
rcorr(high_bqi$BQI_A, high_bqi$hab_qual)

# Medium quality birds only
m_bqi <- bqi_pred_prod%>%
  filter(bqi_cat=="m")
rcorr(m_bqi$BQI_A, m_bqi$hab_qual)


# Plot of BQI by habitat quality by group
bqi_pred_prod%>%
  group_by(bqi_cat)%>%
  summarise(pred_mean=mean(hab_qual),ci=1.96*sd(hab_qual)/sqrt(n()),n=n())%>%
ggplot(aes(bqi_cat,pred_mean, fill=bqi_cat))+
  geom_bar(stat="identity")+ 
  geom_errorbar(aes(ymin=pred_mean - ci,ymax=pred_mean+ci),width=0.2)+
  xlab("breeding quality")

# Test for difference of average habitat quality of low vs high bqi: no sig different, but low birds do have lower mean
t.test(bqi_pred_prod$hab_qual[bqi_pred_prod$bqi_cat=="l"], bqi_pred_prod$hab_qual[bqi_pred_prod$bqi_cat=="h"])
  
      
bqi_mod <- lm(BQI_A~hab_qual+bqi_cat+hab_qual*bqi_cat, data=bqi_pred_prod)
summary(bqi_mod)
anova(bqi_mod)

bqi_mod <- lm(BQI_A~hab_qual, data=bqi_pred_prod)
summary(bqi_mod)
anova(bqi_mod)


# including the last 6 years of breeders (still have to have bred at least 3 times)
bqi_6y_pred_prod <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_bqi_6y_pred_prod.csv")
library(Hmisc)

rcorr(bqi_6y_pred_prod$BQI_A, bqi_6y_pred_prod$GRID_CODE) # no correlation
# low BQI only: better but not significant
low_bqi_6y <- bqi_6y_pred_prod%>%
  filter(BQI_A<0)
rcorr(low_bqi_6y$BQI_A, low_bqi_6y$GRID_CODE)
# High BQI only: worse, not significant
high_bqi_6y <- bqi_6y_pred_prod%>%
  filter(BQI_A>0)
rcorr(high_bqi_6y$BQI_A, high_bqi_6y$GRID_CODE)


```
Predict breeding success at Royds
```{r pred BS at royds}
# Predict breeding success at Cape Royds ####
library(raster)
r_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_area_rast.tif")
ext_r<-extent(r_area)
plot(r_area)
# 
# Need to change this to y n for model
r_skua50<-crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_skua50m_bin.tif"),ext_r)
plot(r_skua50)

r_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_pa_ratio_rast.tif"),ext_r)
plot(r_pa_ratio)

r_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_aspect_corrected.tif"),ext_r)
plot(r_aspect)

r_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_slope"),ext_r)
plot(r_slope)

r_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_mosaic_dem-tile-0_clip_v2.tif"),ext_r)+46
plot(r_elev)

r_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_windshelter300m.asc"),ext_r)
plot(r_windshelt)

r_flow <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_flow_acc_snow_v2.1.tif"),ext_r))
plot(r_flow)

# c_flow[c_flow==-Inf]<-NA


royds_stack <- stack(r_area, r_skua50, r_pa_ratio,r_aspect,r_slope,r_elev,r_windshelt, r_flow)
names(royds_stack)<-c("area","skua50","pa_ratio","mean_aspect","mean_slope","adjust_mean_elev","mean_windshelt","flow_acc_log1p")

# Predict to all subcolonies at Crozier
k=4
r_base_pred <- gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=k, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50, select=TRUE, data=filter(pred_dat,col=="royds"), method="ML")

r_pred_anom <- predict(royds_stack,r_base_pred, type="response")

plot(r_pred_anom, col=rev(rainbow(50, start = 0, end = 0.8, alpha = 1)),main="Predicted habitat quality")
hist(r_pred_anom)
mean(r_pred_anom@data@values, na.rm=TRUE)
sd(r_pred_anom@data@values, na.rm=TRUE)/sqrt(sum(!is.na(r_pred_anom@data@values)))
writeRaster(r_pred_anom, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_predict_prod_base_anom_v2.tif", format="GTiff", overwrite=FALSE)

# calcuated mean BS for last 4 years
r_bs4 <- r_dat%>%
  dplyr::select(season,subcol,prod)%>%
  filter(season%in%c("1415","1516","1617","1718"))
mean(r_bs4$prod)+mean(r_pred_anom@data@values, na.rm=TRUE)

c_bs4 <- c_dat%>%
  dplyr::select(season,subcol,prod)%>%
  filter(season%in%c("1415","1516","1617","1718"))
mean(c_bs4$prod, na.rm=TRUE)+mean(c_pred_anom@data@values, na.rm=TRUE)

```