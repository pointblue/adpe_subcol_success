---
title: "Analysis of variation in reproductive success by subcolony"
author: "Annie Schmidt"
date: "Last edit 18-06-2020" 
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

```{r load libraries and data}

list.of.packages <- c("tidyverse", "mgcv","Hmisc", "stringr","gridExtra","nlme", "raster","sf","nngeo","bbmle")
# # compare to existing packages
# new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
# # install missing packages
# if(length(new.packages)>0) {install.packages(new.packages)}
# load required packages
lapply(list.of.packages, library, character.only = TRUE)

#Set working directory
setwd("Z:/Informatics/S031/analyses/aschmidt/subcol_var")


# read in count data files with subcolony attributes (created by croz(royd)_subcol_ct_data_prep.R) ####
# Crozier
# v18 has windshelter calculated from windshelter_300m_pi_pi8_lcc169 and aspect means corrected for subcols that wrap over 0
c_ct_meas <- read_csv("data/croz_selected_meas_ct_all_v18.csv")


# Royds v10 has windshelter calculated from the South (not SE)
r_ct_meas <- read_csv("data/royds_selected_meas_ct_all_v10.csv")


#Format data for modeling ####
# select columns for analysis
c_dat <- c_ct_meas%>%
  dplyr::select(-FID,-mean_elev, perim)%>%
  mutate(season=factor(season),subcol=factor(subcol), m=ifelse(area_name=="m","y","n"), skua50_yn=factor(ifelse(skua50==1,"y","n")),skua50=factor(skua50))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1415","1516","1617","1718"),!subcol=="s3",!prod=="NA"&!is.na(pa_ratio))%>%
  dplyr::rename(mean_windshelt=mean_windshelt300m, perimeter=perim)


# Format Royds data
r_dat <- r_ct_meas%>%
  dplyr::select(-FID,perimeter,-mean_elev)%>%
  mutate(season=factor(season),subcol=factor(subcol),col=factor(col),skua50_yn=factor(ifelse(skua50==1,"y","n")),skua50=factor(skua50),area_name=as.character(area_name))%>%
  # active count from 13 in 1617 looks off, exclude
  filter(!is.na(active_ct), !active_ct==0,!(subcol=="13"&season=="1617"))%>%
  dplyr::rename(mean_windshelt=mean_windshelt300m)
  
# one slope value for Royds 1b seems off (unlikely it's a 50deg slope)
# Setting it to value from other overpalling pixel = Pixel value	25.368334
# setting slope or 1b to value for other pixel that overlaps (more reasonable)
r_dat[r_dat$subcol=="1b","mean_slope"]=25.3683
# crazy slope causes other variables to be off also, need to reset these also to next pixel
# Flow acc change to 0
r_dat[r_dat$subcol=="1b","flow_acc"]=0
r_dat[r_dat$subcol=="1b","flow_acc_log1p"]=log1p(0)
# aspect to 253.100
r_dat[r_dat$subcol=="1b","mean_aspect"]=253.100
r_dat[r_dat$subcol=="1b","mean_windshelt"]=0.1545
# # elevation to -45.248047+47 (don't think I need to adjust elevation because it looks pretty close in those two cells)
# r_dat[r_dat$subcol=="1b","adjust_mean_elev"]=-45.248047+47 ####check this####

# aspect at Royds is problematic
# because several subcolonies face near north, aspects wrap around from 300 to 0 so average is not accurate
# can't think of a good way to deal with this in Arc and it's only a few so correcting manually with an estimate here
# would be good to come up with a better way to do this
# read in tables for 20b and 4 (the problem ones) that have aspect values by cell
r_aspect_20b <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/rev2/royds_20b_aspect_by_cell.txt")%>%
  dplyr::select(VALUE)%>%
  # if aspect <20, add 360 then calculate mean
  mutate(subcol="20b",aspect_corr=ifelse(VALUE<20,VALUE+360,VALUE))%>%
  group_by(subcol)%>%
  summarise(mean_aspect=mean(aspect_corr))%>%
  # if mean >360, subtract 360
  mutate(mean_aspect=ifelse(mean_aspect>360,mean_aspect-360,mean_aspect))

r_aspect_4 <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/rev2/royds_4_aspect_by_cell.txt")%>%
  dplyr::select(VALUE)%>%
  # if aspect <20, add 360 then calculate mean
  mutate(subcol="4",aspect_corr=ifelse(VALUE<20,VALUE+360,VALUE))%>%
  group_by(subcol)%>%
  summarise(mean_aspect=mean(aspect_corr))%>%
  # if mean >360, subtract 360
  mutate(mean_aspect=ifelse(mean_aspect>360,mean_aspect-360,mean_aspect))

  
r_dat[r_dat$subcol=="20b","mean_aspect"]=r_aspect_20b$mean_aspect
r_dat[r_dat$subcol=="4","mean_aspect"]=r_aspect_4$mean_aspect


# Combine data
all_dat <- c_dat%>%
  full_join(r_dat)%>%
  mutate(subcol=as.factor(subcol), col=as.factor(col),skua50_yn=factor(skua50_yn), season=factor(season))

```            

Check for correlated covariates
```{r check covariate correlation}
# Check covariate correlation
# Define functions #### 
# correlation matrix of data
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- cor(x, y, use="complete.obs")
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * abs(r))
}

pairs(c_dat[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)
# Max abs corr for Croz=0.46
pairs(r_dat[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)
# Max corr for Royds = -0.76 (wind and aspect)
# only two subcol at Royds have flow acc values >0. There are 4 counts at each


```

Subcol Attr
```{r subcol attributes}
# Color for Crozier
col1="#006C84" 
col2="#B2DBD5" # arctic
col3="#5EA8A7" # lagoon


# Subcol attr distributions(Fig 3) ####

# melt data for data vis
subcol_attr <- all_dat%>%
  dplyr::select(col:subcol,area_name:area,pa_ratio,mean_aspect:skua50,flow_acc_log1p)%>%
  gather(attr,value=measurement,-col,-season,-area_name,-subcol)%>%
  mutate(measurement=as.numeric(measurement),attr=factor(attr, labels=c("Elevation (m)","Area (m2)","Flow accumulation (log)","Aspect (deg)","Slope (deg)","Wind shelter index","Perim/Area ratio", "Skua 50m")))%>%
  filter(!is.na(measurement))

# label panels with significant difference
attr_sig <- data.frame(attr=factor(c("Elevation (m)","Area (m2)","Flow accumulation (log)","Aspect (deg)","Slope (deg)","Wind shelter index","Perim/Area ratio"), levels=c("Elevation (m)","Area (m2)","Flow accumulation (log)","Aspect (deg)","Slope (deg)","Wind shelter index","Perim/Area ratio")), sig=as.character(c("*","*","*","*","","*","*")))

subcol_attr%>%
  group_by(subcol,attr)%>%
  dplyr::slice(1)%>%
  filter(!attr=="Skua 50m")%>%
ggplot(aes(attr,measurement, fill=col,color=col))+
  # geom_histogram(bins=20, colour="white")+
  facet_wrap(~attr,scales="free",strip.position = "left")+
    geom_boxplot(width=0.5,alpha = 0.7)+
  # geom_hist(subset=.(attr=="Skua 50m"), bins=2)+
  ylab("")+
  xlab("")+
  # scale_fill_viridis(discrete=TRUE)+
  scale_color_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  guides(fill=guide_legend(title="Colony"),color=guide_legend(title="Colony"))+
  theme_classic()+
  theme(strip.placement.x = "outside",
        strip.placement.y="outside",
    strip.background = element_blank(),
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), panel.border=element_blank(),axis.line= element_line(colour = "black"),axis.text.x=element_blank(),panel.spacing = unit(1.5, "lines"),
    axis.text.y=element_text(size=14),
    text=element_text(size=20),
    plot.margin=margin(t = 10, r = 0, b = 0, l = 0, unit = "pt"))+
    # legend.position="none")+
  guides(fill=guide_legend(title="Colony"))+
  geom_text(data=attr_sig,aes(label=sig),show.legend=FALSE, x=Inf,y=Inf,hjust = 3,
    vjust = 1.5,size=12,inherit.aes = FALSE) # add stars for significant difference

# Note, added skua panel separately in illustrator because couldn't figure out how to do it easily in R
# Skua panel: see below

# Tests for differences between the two colonies

pair_dat <-subcol_attr%>%
  group_by(subcol,attr)%>%
  dplyr::slice(1)%>%
  # filter(!attr=="Skua 50m")%>%
  spread(attr,measurement)

# Most variables not normal so used Mann-Whitney U test
wilcox.test(pair_dat$`Elevation (m)`[pair_dat$col=="croz"],pair_dat$`Elevation (m)`[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Area (m2)`[pair_dat$col=="croz"],pair_dat$`Area (m2)`[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Flow accumulation (log)`[pair_dat$col=="croz"],pair_dat$`Flow accumulation (log)`[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Aspect (deg)`[pair_dat$col=="croz"],pair_dat$`Aspect (deg)`[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Slope (deg)`[pair_dat$col=="croz"],pair_dat$`Slope (deg)`[pair_dat$col=="royds"]) # not significant
wilcox.test(pair_dat$`Wind shelter index`[pair_dat$col=="croz"],pair_dat$`Wind shelter index`[pair_dat$col=="royds"]) 
wilcox.test(pair_dat$`Perim/Area ratio`[pair_dat$col=="croz"],pair_dat$`Perim/Area ratio`[pair_dat$col=="royds"])
wilcox.test(pair_dat$`Skua 50m` [pair_dat$col=="croz"],pair_dat$`Skua 50m`[pair_dat$col=="royds"])

# comparisons between study subcolonies at each colony
# average aspect at each colony
mean(pair_dat$`Aspect (deg)`[pair_dat$col=="croz"])
mean(pair_dat$`Aspect (deg)`[pair_dat$col=="royds"])

# average perimeter/area ration at each colony
mean(pair_dat$`Perim/Area ratio`[pair_dat$col=="croz"])
mean(pair_dat$`Perim/Area ratio`[pair_dat$col=="royds"])

# Test if proportion of subcol with skuas near is different
croz_skua<- sum(pair_dat$`Skua 50m`[pair_dat$col=="croz"])
n_croz<-length(pair_dat$`Skua 50m`[pair_dat$col=="croz"])
royds_skua <- sum(pair_dat$`Skua 50m`[pair_dat$col=="royds"])
n_royds <- length(pair_dat$`Skua 50m`[pair_dat$col=="royds"])

# Having trouble making the skua panel so doing it manually here
# data frame with proportions and CI
prop_skua <- data.frame(croz_skua,n_croz,prop_croz=croz_skua/n_croz,royds_skua,n_royds,prop_royds=royds_skua/n_royds)
# Proportion margin of error
#z*sqrt(p(1-p)/n)
prop_skua$croz_CI <- 1.96*sqrt((prop_skua$prop_croz*(1-prop_skua$prop_croz))/n_croz)
prop_skua$royds_CI <- 1.96*sqrt((prop_skua$prop_royds*(1-prop_skua$prop_royds))/n_royds)

# test if difference in proportion is significant
prop.test(x=c(croz_skua,royds_skua),n=c(n_croz,n_royds))

# plot proportions
prop_skua%>%
  dplyr::select(prop_croz,prop_royds)%>%
  gather(key=col, value=proportion)%>%
  mutate(CI=c(prop_skua$croz_CI,prop_skua$royds_CI))%>%
ggplot(aes(col, proportion, fill=col, color=col))+ 
  geom_bar(stat="identity", 
           position=position_dodge(), alpha=0.6, size=1.1)+
  geom_errorbar(aes(ymin=proportion-CI, ymax=proportion+CI), width=.1,
                 position=position_dodge(.9), size=1.1) +
  ylab("Proportion of subcolonies near skuas")+
  xlab("")+
  scale_color_manual(values=c(col1,col2),guide="none")+
  scale_fill_manual(values=c(col1,col2),guide="none")+
  # guides(fill=guide_legend(title="Colony"),color=guide_legend(title="Colony"))+
  theme_classic()+
  theme(strip.placement.x = "outside",
        strip.placement.y="outside",
    strip.background = element_blank(),
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), panel.border=element_blank(),axis.line= element_line(colour = "black"),axis.text.x=element_blank(),panel.spacing = unit(1.5, "lines"),
    text=element_text(size=24))+
  geom_text(data=attr_sig,aes(label=sig),show.legend=FALSE, x=Inf,y=Inf,hjust = 3,
    vjust = 1.5,size=12,inherit.aes = FALSE)


# plot area vs. perimeter
# all_dat%>%
#   group_by(col,subcol)%>%
#   slice(1)%>%
#   rename(colony=col)%>%
#   ungroup()%>%
#   mutate(ideal_y=2*pi*sqrt(area/pi), r=sqrt(area/pi),ideal_pa=2/r,resid=pa_ratio-ideal_pa)%>%
# ggplot(aes(area,resid))+
#   geom_point(aes(colour=colony))+
#   # geom_line(aes(area,ideal_pa))
#   geom_smooth(method="loess",aes(fill=colony, col=colony))

# Croz and Royds productivity together ####
# Read in historic royds counts
r_ct_all <- read_csv("data/royds_all_ct_clean_thru1718.csv")

cr_count_all <- c_ct_meas%>%
  full_join(r_ct_all)%>%
  dplyr::select(col,subcol,season,prod)%>%
  mutate(season=factor(season,labels=c("2002","2003","2004","2005","2006","2007","2008","2009","2010","2011","2012",
                                      "2013","2014","2015","2016","2017")))%>%
  filter(!is.na(prod))

# Plot time series together (Fig 2.) ####
ggplot(cr_count_all,aes(season,prod, fill=col, color=col))+
  geom_boxplot(alpha = 0.7,position = position_dodge(preserve = "single"))+
  ylab("Breeding success (chicks/pair)")+
  xlab("Season")+
  # stat_summary(fun.y=mean, geom="point", 
  #              shape=19, size=3,show.legend = FALSE,position=position_dodge(width=0.7)) +
  scale_color_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  guides(fill=guide_legend(title="Colony"),color=guide_legend(title="Colony"))+
  theme_classic()


# Royds CV
r_cv_seas<-r_ct_all%>%
  group_by(season)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
mean(r_cv_seas$cv, na.rm=TRUE)
sd(r_cv_seas$mean,na.rm=TRUE)/mean(r_cv_seas$mean, na.rm=TRUE)
plot(r_cv_seas$season,r_cv_seas$cv,type="o", ylim=c(0,1))

r_cv_sub<-r_ct_all%>%
  group_by(subcol)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
mean(r_cv_sub$cv, na.rm=TRUE)
mean(r_ct_all$prod)
mean(r_cv_seas$mean)

sd(r_ct_all$prod)/mean(r_ct_all$prod)  

# Croz CV
c_cv_seas<-c_ct_meas%>%
  group_by(season)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
mean(c_cv_seas$cv, na.rm=TRUE)
par(mfrow=c(1,1))
plot(r_cv_seas$season,r_cv_seas$cv,type="o", ylim=c(0,1))
lines(c_cv_seas$season,c_cv_seas$cv,type="o", lwd=2)
sd(c_cv_seas$mean,na.rm=TRUE)/mean(c_cv_seas$mean, na.rm=TRUE)
sd(c_ct_meas$prod,na.rm=TRUE)/mean(c_ct_meas$prod, na.rm=TRUE) 
mean(c_ct_meas$prod, na.rm=TRUE)


# Mean and SE of chicks per pair for whole time series
sd(c_ct_meas$prod,na.rm=TRUE)/sqrt(length(c_ct_meas$prod)-5) # 5 NA's
mean(c_dat$prod, na.rm=TRUE)
# Croz SE
sd(c_dat$prod)/sqrt(length(c_dat$prod))
# Royds SE
sd(r_ct_all$prod)/sqrt(length(r_ct_all$prod))

# mean for 4 years of study
# Royds
mean(r_dat$prod)
sd(r_dat$prod)/sqrt(length(r_dat$prod))
# Croz
mean(c_dat$prod)
sd(c_dat$prod)/sqrt(length(c_dat$prod))

# Coefficient of variation
# Royds
r_cv_seas_4<-r_ct_all%>%
  filter(season%in%c("1415","1516","1617","1718"))%>%
  group_by(season)%>%
  summarise(mean=mean(prod),sd=sd(prod))%>%
  mutate(cv=sd/mean)
mean(r_cv_seas_4$cv, na.rm=TRUE)

# Crozier
c_cv_seas_4<-c_ct_meas%>%
  filter(season%in%c("1415","1516","1617","1718"))%>%
  group_by(season)%>%
  summarise(mean=mean(prod),sd=sd(prod))%>%
  mutate(cv=sd/mean)
mean(c_cv_seas_4$cv, na.rm=TRUE)


# statistics requested during review ####
# correlation between subcol area and count
cor_area_ct <-all_dat%>%
  # group_by(col)%>%
  summarise(r=cor(area,active_ct),p=cor.test(area,active_ct)$p.value)

# number of subcol with 4 counts
summ_cts_4 <- all_dat%>%
  group_by(col,subcol)%>%
  summarise(n=n())%>%
  group_by(col,n)%>%
  summarise(n4=n())

# number of subcolonies counted each year
summ_cts_yr <- all_dat%>%
  group_by(col,season)%>%
  summarise(n=n())

# Difference in means for whole time series
t_cr_all <- t.test(c_ct_meas$prod, r_ct_all$prod)
# fit gls model to test for differences in means
# requires library()
nestinginfo <- groupedData(prod ~ col | subcol, data= cr_count_all)
fit.compsym <- gls(prod ~ factor(col), data=nestinginfo, corr=corCompSymm(,form= ~ 1 | subcol))
summary(fit.compsym)
fit.ar1 <- gls(prod ~ factor(col), data=nestinginfo, corr=corAR1(, form= ~ 1 | subcol))
summary(fit.ar1)
anova(fit.compsym,fit.ar1)

# difference in means for 4 years of study
cr_4 <- cr_count_all%>%
  filter(season%in%c("2014","2015","2016","2017"))


# fit gls model to test for differences in means
nestinginfo4 <- groupedData(prod ~ col | subcol, data= all_dat)
fit.compsym4 <- gls(prod ~ factor(col), data=nestinginfo4, corr=corCompSymm(,form= ~ 1 | subcol))
summary(fit.compsym4)
fit.ar14 <- gls(prod ~ factor(col), data=nestinginfo4, corr=corAR1(, form= ~ 1 | subcol))
summary(fit.ar14)
anova(fit.compsym4,fit.ar14)




```

Crozier GAM
```{r Crozier GAM}
# Starting with model with all variables of interest subcol id as random effect
# using REML based on recommendation in Marra and Wood 2011
# # Except if I want to compare models with different fixed effects I shouldn't
# # https://stats.stackexchange.com/questions/116770/reml-or-ml-to-compare-two-mixed-effects-models-with-differing-fixed-effects-but?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
# # thread suggests using REML because it does a better job with random effects on just your final model for inference and prediction

# remove annual mean so just modeling the spatial variability, not the annual variability
ann_prod_anom<-all_dat%>%
  group_by(col,season)%>%
  dplyr::summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod)%>%
  mutate_at(vars(area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,flow_acc,flow_acc_log,flow_acc_log1p),funs(scale))
# plot(ann_prod_anom$subcol,ann_prod_anom$prod_anom)

# Set k=6
ck=6
# Fit model with no interactions
# initial submission had fit model with ML because though I couldn't compare models using REML. But REML supposed to be better and gam (mgcv) help indicates ok to compare using AICc so switching  
c_base_anom <-gam(prod_anom~s(area, k=ck)+s(pa_ratio, k=ck)+s(mean_slope, k=ck)+s(mean_aspect,k=ck, bs="cc") +s(adjust_mean_elev,k=ck)+s(flow_acc_log1p,k=ck)+ s(mean_windshelt,k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
# check if basis dimensions sifficient
par(mfrow=c(2,2))
gam.check(c_base_anom) # flow p-value is significant, but edf not close to k so not adjusting
summary(c_base_anom)
plot(c_base_anom,pages=1, residuals=T)
concurvity(c_base_anom) # everything <0.8 in the estimate row
round(concurvity(c_base_anom, full=FALSE)$estimate,2) # nothing over 0.49
par(mfrow=c(2,2))
gam.check(c_base_anom)


# Fit model with seasonal interaction
c_seasonx_anom <-gam(prod_anom~s(area, by=season, k=ck) + s(pa_ratio, by=season, k=ck)+s(adjust_mean_elev,by=season, k=ck)+s(mean_slope, by=season, k=ck) +s(mean_aspect,by=season,k=ck, bs="cc") +s(mean_windshelt,by=season,k=ck)+s(flow_acc_log1p,by=season)+skua50*season, data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
summary(c_seasonx_anom)

plot.gam(c_seasonx_anom,pages=1, shade=TRUE)


# check how compare
library(bbmle)
AICctab(c_base_anom,c_seasonx_anom,nobs=292, base=TRUE, weights=TRUE, logLik=TRUE)


```

Gams for Royds
```{r Royds Gams, echo=FALSE}

# set k for royds
rk=4
r_mdat <-filter(ann_prod_anom,col=="royds")
r_mdat%>%
 group_by(subcol)%>%
  dplyr::slice(1)%>%
  filter(pa_ratio>0&pa_ratio<1)

# flow at Royds has non-zero estimates at only 2 subcolonies, doesn't seem like a good idea to include
# Fit model with no interactions
r_base_anom <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk) +s(mean_windshelt,k=rk)+s(mean_aspect,k=rk, bs="cc")+flow_acc_log1p+skua50, data=r_mdat, method="ML", select="TRUE",na.action="na.pass")
summary(r_base_anom)
gam.check(r_base_anom, pages=1) # looks pretty good, some skew in the residuals
concurvity(r_base_anom) # estimates all >0.8
round(concurvity(r_base_anom, full=FALSE)$estimate,2) # but nothing in pairwise comparisons above 0.58
plot.gam(r_base_anom, pages=1)

# model above is behaving oddly with respect to windshelter and pa-ratio
# windshelter and aspect are pretty highly correlated (-0.76)
# so running models with each independently
r_base_wind <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk) +s(mean_windshelt,k=rk)+flow_acc_log1p+skua50, data=r_mdat, select=TRUE, method="ML")
gam.check(r_base_wind)
summary(r_base_wind)
plot.gam(r_base_wind, pages=1, shade=T, residuals=T)

r_base_aspect <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk) +s(mean_aspect,k=rk, bs="cc")+flow_acc_log1p+skua50, data=r_mdat, select=TRUE, method="ML")
gam.check(r_base_aspect)
concurvity(r_base_aspect) # several estimates >0.8, pa-ratio and slope
round(concurvity(r_base_aspect, full=FALSE)$estimate,2) # pa ratio highest, highest concurvity with area and elevation. not much variability in elevation so could remove. Highest concurvity is 0.58 so think I could justify that that is OK
summary(r_base_aspect)
plot.gam(r_base_aspect, pages=1, shade=T, residuals=T)

# r_base2 <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk)+skua50, data=r_mdat, select=TRUE, method="ML")
# 
# r_base3 <-gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk)+flow_acc_log1p, data=r_mdat, select=TRUE, method="ML")
# 
# r_base4 <-gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk), data=r_mdat, select=TRUE, method="ML")

r_seasonx<-  gam(prod_anom~s(area,by=season,k=rk) + s(pa_ratio, by=season,k=rk)+ s(adjust_mean_elev,by=season, k=rk)+s(mean_slope,by=season,k=rk)+ flow_acc_log1p*season+ skua50*season, data=r_mdat, select=TRUE, method="ML")
gam.check(r_seasonx_anom)

library(bbmle)
AICctab(r_base_wind,r_base_aspect,r_seasonx,nobs=86, base=TRUE, weights=TRUE, logLik=TRUE)

```

Tables
```{r tables for manuscript}
# make model output table with gt package ####
library(gt)
r_mod_list <- list(r_base_wind,r_base_aspect,r_seasonx_aspect)
r_mod_names <-c("r_base_wind","r_base_aspect","r_seasonx_aspect")

# make table with % dev explained to join to model table
r_devexpl <- data.frame(Model=c("m1", "m2","m3"),dev.expl=round(c(summary(r_mod_list[[1]])$dev.expl, summary(r_mod_list[[2]])$dev.expl,summary(r_mod_list[[3]])$dev.expl),1),
                        description=c("base (-aspect)", "base (-wind shelter)", "m2 x year"))

rmod_tab <- as.data.frame(AICctab(r_mod_list,nobs=86, weights=TRUE, base=TRUE,logLik=TRUE, mnames=c("m1", "m2","m3")))%>%
  mutate(Model=rownames(.),Colony="Cape Royds", n=86)%>%
  mutate_if(is.numeric,funs(round(.,2)))%>%
  full_join(r_devexpl)

# crozier model tables
c_mod_list <- list(c_base_anom, c_seasonx_anom)
c_mod_names <- c("c_base_anom", "c_seasonx_anom")
c_devexpl <- data.frame(Model=c("m1", "m2"),dev.expl=round(c(summary(c_mod_list[[1]])$dev.expl, summary(c_mod_list[[2]])$dev.expl),2),
                        description=c("base", "m1 x year"))

cmod_tab<-as.data.frame(AICctab(c_base_anom,c_seasonx_anom,nobs=292, weights=TRUE, logLik=TRUE,base=TRUE, mnames=c("m1", "m2")))%>%
  mutate(Model=rownames(.),Colony="Cape Crozier", n=292)%>%
  mutate_if(is.numeric,funs(round(.,2)))%>%
  full_join(c_devexpl)

mod_tab <- rbind(rmod_tab,cmod_tab)%>%
  gt(rowname_col = "Model", groupname_col = "Colony")%>%
  tab_stubhead(label="Model")%>%
  cols_label(dLogLik=html("&Delta;Loglik"),
             dAICc=html("&Delta;AICc"),
             dev.expl=html("Dev. explain"))%>%
   cols_align("left")%>%
  cols_move_to_start(columns=c("Model", "description"))%>%
  tab_source_note(source_note = "base model covariates: area + perimeter/area ratio + slope + aspect + elevation +  flow accumulation + wind shelter index +  skua within 50m")



```
Proportion Deviance explained
```{r calculate proportion deviance explained}

# Calculate proportion deviance explained by each model
# Example fount here: http://r.789695.n4.nabble.com/variance-explained-by-each-term-in-a-GAM-td836513.html
# https://r.789695.n4.nabble.com/Re-variance-explained-by-each-predictor-in-GAM-td896222.html
# b <- gam(y~s(x1)+s(x2))
# > b1 <- gam(y~s(x1),sp=b$sp[1])
# > b2 <- gam(y~s(x2),sp=b$sp[2])
# > b0 <- gam(y~1)
# > ## calculate proportions deviance explained...
# > (deviance(b1)-deviance(b))/deviance(b0) ## prop explained by s(x2)
# > (deviance(b2)-deviance(b))/deviance(b0) ## prop explained by s(x1)

# rethinking how I'm calculating proportion deviance explained
# don't think it makes sense to refit models including skua since can't pass smoothing paramters so it's reestimating the skua coefficient which is changing the model (?)
# so now calculating the proportion deviance explained by each model by fitting a model with smoothers passed from base model but comparing to model with skuas removed (and smoothers passed from original)

cb<-update(c_base_anom,.~.-skua50,sp=c_base_anom$sp) # model for comparison with skua removed
c_base_anom <-gam(prod_anom~s(area, k=ck)+s(pa_ratio, k=ck)+s(mean_slope, k=ck)+s(mean_aspect,k=ck, bs="cc") +s(adjust_mean_elev,k=ck)+s(flow_acc_log1p,k=ck)+ s(mean_windshelt,k=ck)+skua50, data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
# Fit intercept only model
cb0 <- gam(prod_anom~1, data=filter(ann_prod_anom,col=="croz"), method="REML")
summary(cb0)
method="ML"

# Fit model with pa ratio removed and smooths for all other variables supplied from base model
# Area and wind already dropped


#### Note: order of variables must match base model!

# area already selected out
#pa ratio removed
cb1 <-update(cb,.~.-s(pa_ratio, k=ck),sp=c_base_anom$sp[-c(3,4)])
summary(cb1)
plot(cb1,pages=1)
# slope removed
cb2 <- update(cb, .~.-s(mean_slope,k=ck),sp=c_base_anom$sp[-c(5,6)])
summary(cb2)
plot(cb2,pages=1)

# Aspect removed
cb3 <-update(cb,.~.-s(mean_aspect,k=ck, bs="cc"),sp=c_base_anom$sp[-7])
summary(cb3)
plot(cb3, pages=1)

# elevation removed
cb4 <-update(cb,.~.-s(adjust_mean_elev, k=ck),sp=c_base_anom$sp[-c(8,9)])
summary(cb4)
plot(cb2, pages=1)

# flow accumulation removed
cb5 <- update(cb,.~.-s(flow_acc_log1p, k=ck),sp=c_base_anom$sp[-c(10,11)])
summary(cb5)
plot(cb5,pages=1)

# windshelter already selected out
#Skua removed
cb6 <- update(c_base_anom,.~.-skua50,sp=c_base_anom$sp) # cb6 is the same as cb


# Croz Proportion
c_pa_ndevex <- summary(cb)$dev.expl-summary(cb1)$dev.expl
c_slope_ndevex <- summary(cb)$dev.expl-summary(cb2)$dev.expl
c_aspect_ndevex <- summary(cb)$dev.expl-summary(cb3)$dev.expl
c_elev_ndevex <- summary(cb)$dev.expl-summary(cb4)$dev.expl
c_flood_ndevex<- summary(cb)$dev.expl-summary(cb5)$dev.expl
# c_skua_ndevex<- ((deviance(cb6)-deviance(cb))/deviance(cb0))
# calculate skua diff between smoother only model and all smoothers + skua (top_mod)
c_skua_ndevex <- summary(c_base_anom)$dev.expl-summary(cb6)$dev.expl


# Royds
rb0 <- gam(prod_anom~1, data=filter(ann_prod_anom,col=="royds"), method="ML")
rb <- update(r_base_aspect_1.2,.~.-skua50,sp=r_base_aspect$sp)
rb<-top_mod
plot(rb,pages=1)
plot(r_base_aspect,pages=1)
method="ML"
top_mod=r_base_aspect
rb=r_base_aspect


#pa ratio removed
rb1 <-update(rb,.~.-s(pa_ratio, k=rk),sp=top_mod$sp[-c(3,4)])
summary(rb1)
plot(rb1,pages=1)

# rb1.1 <- update(top_mod,.~.-s(pa_ratio, k=rk),sp=top_mod$sp[-c(3,4)])
# elevation removed
rb2 <-update(rb,.~.-s(adjust_mean_elev, k=rk),sp=top_mod$sp[-c(5,6)])
summary(rb2)
plot(rb2, pages=1)
# Fit model with slope removed
rb3 <- update(rb, .~.-s(mean_slope,k=rk),sp=top_mod$sp[-c(7,8)])
summary(rb3)
plot(rb3,pages=1)
# Aspect removed
# rb4 <-update(rb,.~.-s(mean_aspect,k=rk, bs="cc"),sp=top_mod$sp[-9])
# summary(rb4)
# plot(rb4, pages=1)
# flow accumulation removed
rb5 <- update(rb,.~.-flow_acc_log1p,sp=top_mod$sp)
summary(rb5)
plot(rb5,pages=1)
#Skua removed
rb6 <- update(r_base_aspect,.~.-skua50,sp=r_base_aspect$sp)
# area removed
rb7 <- update(rb,.~.-s(area,k=rk),sp=top_mod$sp[-c(1,2)])


# Proportion deviance explained
r_pa_ndevex <- summary(rb)$dev.expl-summary(rb1)$dev.expl
r_elev_ndevex <- summary(rb)$dev.expl-summary(rb2)$dev.expl
r_slope_ndevex <- summary(rb)$dev.expl-summary(rb3)$dev.expl
# r_aspect_ndevex<- summary(rb)$dev.expl-summary(rb4)$dev.expl
r_flood_ndevex<- summary(rb)$dev.expl-summary(rb5)$dev.expl
# calculate skua diff between smoother only model and all smoothers + skua (top_mod)
r_skua_ndevex <- summary(top_mod)$dev.expl-summary(rb6)$dev.expl

# percent change in R2 when each variable removed
r_area_r2 <-(summary(rb)$r.sq-summary(rb7)$r.sq)*100/summary(rb)$r.sq
r_pa_r2 <- (summary(rb)$r.sq-summary(rb1)$r.sq)*100/summary(rb)$r.sq
r_elev_r2 <- (summary(rb)$r.sq-summary(rb2)$r.sq)*100/summary(rb)$r.sq
r_slope_r2 <- (summary(rb)$r.sq-summary(rb3)$r.sq)*100/summary(rb)$r.sq
# r_aspect_ndevex<- summary(rb)$dev.expl-summary(rb4)$dev.expl
r_flood_r2<- (summary(rb)$r.sq-summary(rb5)$r.sq)*100/summary(rb)$r.sq
# calculate skua diff between smoother only model and all smoothers + skua (top_mod)
r_skua_r2 <- (summary(top_mod)$r.sq-summary(rb6)$r.sq)*100/summary(rb)$r.sq

# sum(r_pa_r2,r_elev_ndevex,r_slope_r2,r_flood_r2,r_skua_r2)
# Make table to proportion deviance explained
rb_term_ndevex <- round(c(0,r_pa_ndevex,r_elev_ndevex,r_slope_ndevex,0,NA,r_flood_ndevex,r_skua_ndevex),3)

rb_term_r2 <- round(c(r_area_r2,r_pa_r2,r_elev_r2,r_slope_r2,0,NA,r_flood_r2,r_skua_r2),1)

sum(rb_term_ndevex, na.rm=TRUE)

cb_term_ndevex<- round(c(0,c_pa_ndevex,c_elev_ndevex, c_slope_ndevex,c_aspect_ndevex, 0,c_flood_ndevex, c_skua_ndevex),3)
sum(cb_term_ndevex)

term_devex <- data.frame(term=c("Area","Perim/area_ratio","Elevation","Slope","Aspect","Wind_shelter", "flow_acc","skua"), Croz_ndevex=cb_term_ndevex,Royds_ndevex=rb_term_ndevex)

# write.csv(term_devex,"Z:/Informatics/S031/analyses/aschmidt/subcol_var/results/gam_model_term_deviance_explained_v5.csv")



```

Model figures
```{r model figs}

croz_ann_prod <- filter(ann_prod_anom,col=="croz")%>%
  mutate(predict_base=predict(c_base_anom))

royds_ann_prod <- filter(ann_prod_anom,col=="royds")%>%
  mutate(predict_base=predict(r_base_anom))

ann_prod_pred<-croz_ann_prod%>%
  full_join(royds_ann_prod)
# c_obs_v_pred<-ggplot(croz_ann_prod,aes(prod_anom,predict_cbase))+
#   geom_point()+
#   geom_smooth(method="lm",colour="black")+
#   xlab("Observed breeding success")+
#   ylab("Predicted breeding success")+
#   theme_classic()

ggplot(ann_prod_pred,aes(prod_anom,predict_base, colour=col))+
  geom_point(aes(shape=col, color=col),size=2)+
  geom_smooth(method="lm",show.legend = FALSE,aes(fill=col),alpha=0.4)+
  geom_abline(slope=1, intercept=0)+
  xlab("Observed breeding success")+
  ylab("Predicted breeding success")+
  # scale_colour_manual(values=c("#FF3366","grey60"),name="Colony",labels = c("Crozier","Royds"))+
  scale_colour_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))+
  scale_shape(name="Colony",labels=c("Crozier","Royds"))+
  theme_classic()


# ggplot(bqi_pred_prod,aes(hab_qual,BQI_A, color=bqi_cat))+
#   geom_point()+geom_smooth(method=lm)+
#   xlab("Habitat quality")+
#   ylab("Breeding quality index (BQI)")+
#   # scale_colour_manual(values = c("Black", "lightgrey", "grey50"))
#   scale_colour_grey(labels = c("High","Medium","Low"))+
#   # theme_bw()+ 
#   guides(colour=guide_legend(title="BQI/ncategory"))+
#   theme_classic()
  
# c_ovp<-ggplot(croz_ann_prod,aes(prod_anom,predict_cbase_REML))+
#   geom_point()+
#    geom_smooth(method="lm",colour="black")+
#   xlab("Observed breeding success")+
#   ylab("Predicted breeding success")+
#   ylim(c(-0.7,0.7))+
#   xlim(c(-0.7,0.7))+
#   theme_classic()+
#   geom_text(x=-0.6, y=0.4, label="C. Crozier")
# print(c_ovp)

# 
rcorr(croz_ann_prod$prod_anom,croz_ann_prod$predict_base)
rcorr(royds_ann_prod$prod_anom,royds_ann_prod$predict_base)
# 
# 
# r_ovp<-ggplot(royds_ann_prod,aes(prod_anom,predict_base))+
#   geom_point()+
#    geom_smooth(method="lm",colour="black")+
#   xlab("Observed breeding success")+
#   ylab("Predicted breeding success")+
#   ylim(c(-0.7,0.7))+
#   xlim(c(-0.7,0.7))+
#   geom_text(x=-0.6, y=0.4, label="C. Royds")+
#   theme_classic()
# print(r_ovp)
# 
# grid.arrange(grobs=list(c_ovp,r_ovp), nrow=2)

# Model plots ####
pred_dat<- all_dat%>%
  group_by(col,season)%>%
  dplyr::summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(dplyr::n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod, skua50=as.factor(skua50))%>%
  ungroup()

c_base_pred <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, select=TRUE, data=filter(pred_dat,col=="croz"), method="ML")

rk=4
r_base_pred <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc") +s(mean_windshelt,k=rk)+s(flow_acc_log1p, k=rk)+skua50, select=TRUE, data=filter(pred_dat,col=="royds"), method="ML")



```
New Figure 4 for revision
```{r new Fig 4}
# Need to do them one at a time to modify labels


# Making a new function to do this
# need to predict each partial smooth and then plot
plot.smooths <- function(x, data, model, ylim=NULL, xlim=NULL,xlab=NULL,ylab="Effect on/n breeding success",col_x, add){
#create a sequence of new data for variable of interest
new_dat <- seq(min(data[,x]),max(data[,x]),length=nrow(data))
# predict partial smooth
data[,x] <- new_dat
# predict with new data
pred <- predict(model,type="terms",newdata=data,se.fit=TRUE)
fit<-data.frame(pred$fit)
fit.up95<-fit-1.96*pred$se.fit
fit.low95<-fit+1.96*pred$se.fit
s.var <- paste("s.",x,".",sep="")
plot_dat <- data.frame(x=data[,x],fit_var=fit[,s.var])
# plot smooth but leave blank for now so that we can add the line on top of the polygon
if(add==FALSE){
plot(plot_dat[,x],plot_dat[,"fit_var"],ylim=ylim,xlim=xlim,add=add, xlab=xlab,ylab=ylab, type="n")
  polygon(c(new_dat, rev(new_dat)), 
        c(fit.low95[,s.var],rev(fit.up95[,s.var])), col=alpha(col_x,0.7),border=NA)
# add predicted line
lines(plot_dat[,x],plot_dat[,"fit_var"],  lwd=1, col=col_x)
} else {
# For the confidence grey polygon
polygon(c(new_dat, rev(new_dat)), 
        c(fit.low95[,s.var],rev(fit.up95[,s.var])), col=alpha(col_x,0.7),border=NA)
# add predicted line
lines(plot_dat[,x],plot_dat[,"fit_var"],  lwd=1, col=col_x)
}
}


# Croz and Royds on same panel
dev.new()
cairo_ps()
par(mfrow=c(4,2),mar=c(3,4,2,1),mgp=c(2.1,0.4,0), las=1, tck=-0.02)
ylim=c(-1,0.45)

# Area ##
# Croz
xlim <- c(min(pred_dat[pred_dat$col=="croz","area"],pred_dat[pred_dat$col=="royds","area"]),max(pred_dat[pred_dat$col=="croz","area"],pred_dat[pred_dat$col=="royds","area"]))
plot.smooths(x="area",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Area",col_x=col1)
plot.smooths(x="area",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Area",col_x=col2)


# PA ratio
var="pa_ratio"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="pa_ratio",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Perim/Area ratio",col_x=col1)
plot.smooths(x="pa_ratio",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Perim/Area ratio",col_x=col2)
legend("bottomleft", legend=c("Crozier", "Royds"), col=c(col1, col2), border=c(col1,col2), fill=c(col1,col2))

# Elevation
var="adjust_mean_elev"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="adjust_mean_elev",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Elevation",col_x=col1)
plot.smooths(x="adjust_mean_elev",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Elevation",col_x=col2)

# Slope
var="mean_slope"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="mean_slope",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Slope",col_x=col1)
plot.smooths(x="mean_slope",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Slope",col_x=col2)

# Aspect
var="mean_aspect"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="mean_aspect",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Aspect",col_x=col1)
plot.smooths(x="mean_aspect",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlim=xlim,xlab="Aspect",col_x=col2)

# Wind shelter
var="mean_windshelt"
xlim <- c(min(pred_dat[,var]),max(pred_dat[,var]))
plot.smooths(x="mean_windshelt",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Wind shelter",col_x=col1)
plot.smooths(x="mean_windshelt",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlim=xlim,xlab="Wind shelter",col_x=col2)

# Flow accumulation
# Wind shelter
var="flow_acc_log1p"
xlim <- c(min(pred_dat[,var]),max(pred_dat[,var]))
plot.smooths(x="flow_acc_log1p",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Flow accumulation",col_x=col1)
plot.smooths(x="flow_acc_log1p",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Flow accumulation",col_x=col2)

# Skua
var="skua50"
# doing this one from scratch
c_skua0 <- c_base_pred$coefficients[1]
c_skua1<-c_skua0+c_base_pred$coefficients[2]
c_skua0_se <- summary(c_base_pred)$se[1]
c_skua1_se <- summary(c_base_pred)$se[2]

r_skua0 <- r_base_pred$coefficients[1]
r_skua1<-r_skua0+r_base_pred$coefficients[2]
r_skua0_se <- summary(r_base_pred)$se[1]
r_skua1_se <- summary(r_base_pred)$se[2]

cr_skua <- data.frame(col=c("croz","croz", "royds","royds"),
                      skua50=factor(c(0,1,0,1)),
                      coef=c(c_skua0, c_skua1, r_skua0, r_skua1),
                      ci=c(1.96*c_skua0_se, 1.96*c_skua1_se,1.96*r_skua0_se,1.96*r_skua1_se))

skua_mod<-ggplot(cr_skua,aes(skua50,coef,col=col))+
  geom_point(size=2,position=position_dodge(width=0.15))+
  geom_errorbar(aes(ymin=coef-ci,ymax=coef+ci),width=0.1, size=0.5,position=position_dodge(width=0.15))+
  theme_bw()+
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title=element_text(size=8),
        axis.text=element_text(size=8),
        plot.margin = margin(17,10,0,1, "pt"),
        axis.title.x=element_text(margin = margin(t = 8, r = 0, b = 0, l = 0)))+
  ylab("Effect on/n breeding success")+
  xlab("Skua within 50m")+
  ylim(ylim)+
  scale_colour_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))


plot.new()
vp <- grid::viewport(height = unit(0.25,"npc"), width=unit(0.5, "npc"), 
              just = c("left","bottom"),
              y = 0, x = 0.5,layout.pos.row = 4,layout.pos.col = 2)
print(skua_mod, vp = vp)


```
Old Fig 4
```{r old fig 4}
# 
# plot.smooths(x="skua50",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Skua within 50m",col_x=col1)
# plot.smooths(x="skua50",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Skua within 50m",col_x=col2)
# c_base_pred$terms


# Old version of figure (from original submission)

# Area ##
# Croz
plot.gam(c_base_pred,select=1, xlab="Area",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Crozier", shade.col=alpha(col1,0.7),col=col1)

# Royds
plot.gam(r_base_pred,select=1, xlab="Area",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Royds", shade.col = alpha(col2,0.7),col=col3)

test <- plot.gam(r_base_pred,select=1, xlab="Area",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Royds", shade.col = alpha(col2,0.7),col=col3)[[1]]$x
lines(test, r_area_gam_fit)

# PA ratio ##
# Croz
plot.gam(c_base_pred,select=2, xlab="Perim/Area ratio",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,main="Crozier",shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=2, xlab="Perim/Area ratio",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim, main="Royds",shade.col = alpha(col2,0.7),col=col3)

# Elevation ##
# Croz
plot.gam(c_base_pred,select=3, xlab="Elevation", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=3, xlab="Elevation", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Slope##
# Croz
plot.gam(c_base_pred,select=4, xlab="Slope", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=4, xlab="Slope", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Aspect
# Croz
plot.gam(c_base_pred,select=5, xlab="Aspect", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=5, xlab="Aspect", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Wind shelter
# Croz
plot.gam(c_base_pred,select=6, xlab="Wind shelter", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=6, xlab="Wind shelter", se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col=col3)

# Flow accumulation
# Croz
plot.gam(c_base_pred,select=7, xlab="Flow accumulation",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="Breeding Success",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col=alpha(col1,0.7),col=col1)
# Royds
plot.gam(r_base_pred,select=7, xlab="Flow accumulation",se=TRUE, scheme=1, shade=T, pch=19, cex=0.5, ylab="",seWithMean = TRUE,cex.lab=1.3,ylim=ylim,shade.col = alpha(col2,0.7),col="#5EA8A7")

# Skua
# Croz
termplot(c_base_pred, terms=c("skua50"), se=TRUE, col.term= col1, lwd.term=3, lwd.se=1,lty.se = 1,col.se=col1, use.factor.levels = TRUE, pch=19, ylab="Breeding success", xlab="Skua within 50m",ylim=ylim)
# Royds
termplot(r_base_pred, terms=c("skua50"), se=TRUE, col.term= col3, lwd.term=3, lwd.se=1,lty.se = 1,col.se=col3, use.factor.levels = TRUE, pch=19, ylab="Breeding success", xlab="Skua within 50m",ylim=ylim, add=TRUE)




```

Predict Productivity Spatially
```{r Predict productivity to space and correlate to BQI}
# read in rasters to use for prediction
library(raster)
# format data for prediction
# calculate productivity anomaly but do not scale other variables
pred_dat<- all_dat%>%
  group_by(col,season)%>%
  summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod, skua50=as.factor(skua50))
k=6
c_base_pred <- gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=k, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50, select=TRUE, data=filter(pred_dat,col=="croz"), method="ML")

plot(c_base_pred, pages=1)
summary(c_base_pred)
c_base_pred_val<- predict(c_base_pred)
plot(croz_ann_prod$prod_anom,c_base_pred_val)
cor(croz_ann_prod$prod_anom,c_base_pred_val)



# Load in raster data sets
# Need all variables even though some get dropped
library(raster)
c_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_area_rast.tif")
ext<-extent(c_area)
plot(c_area)
# 
# Need to change this to y n for model
c_skua50<-crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_skua50mbin_rast.tif"),ext)
plot(c_skua50)

c_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_pa_ratio_rast.tif"),ext)
plot(c_pa_ratio)

c_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_aspect.tif"),ext)
plot(c_aspect)

c_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_slope.tif"),ext)
plot(c_slope)

c_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_elev.tif"),ext)+47
plot(c_elev)

c_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_windselt.tif"),ext)
plot(c_windshelt)

c_flow <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_flow_acc.tif"),ext))
plot(c_flow)

c_flow[c_flow==-Inf]<-NA

croz_stack <- stack(c_area, c_skua50, c_pa_ratio,c_aspect, c_slope,c_elev,c_windshelt, c_flow)
names(croz_stack)<-c("area","skua50","pa_ratio","mean_aspect","mean_slope","adjust_mean_elev","mean_windshelt","flow_acc_log1p")

# Predict subcolony quality to all subcolonies at Crozier
c_pred_anom <- predict(croz_stack,c_base_pred, type="response")

plot(c_pred_anom, col=rev(rainbow(50, start = 0, end = 0.8, alpha = 1)),main="Predicted subcolony quality")
hist(c_pred_anom@data@values)
mean(c_pred_anom@data@values, na.rm=TRUE)
sd(c_pred_anom@data@values, na.rm=TRUE)/sqrt(sum(!is.na(c_pred_anom@data@values)))
writeRaster(c_pred_anom, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_subcol.tif", format="GTiff", overwrite=FALSE)
# 


# Correlate predicted prod/habitat quality with individual quality ####
# need to create a table with last BQI value for each bandnumb
c_bqi<- read.csv("Z:/Informatics/S031/analyses/BQI/BQI_inclcurseas_1998to2017_forAnnie.csv", header=TRUE)%>%
  mutate(season_yr=Season,season = plyr::mapvalues(Season, 
                         from = factor(c(1998:2017)),
                         to = c("9899","9900","0001","0102","0203","0304","0405",
                                "0506","0607","0708","0809","0910","1011","1112",
                                "1213","1314","1415","1516","1617","1718")))

ggplot(c_bqi,aes(Br_exp,BQI_A,group=Bandnumb))+
  geom_line(aes(colour=Bandnumb))
  

# Read in resigt data to get coordinates where bred
allresight_raw <- read.csv("Z:/Informatics/S031/S0311920/croz1920/bandsearch/allresight_1819.csv", as.is=TRUE)%>%
  mutate(bandnumb=as.numeric(bandnumb),lat=as.numeric(lat))

# Filter to lines that have gps location
allrs_latlon <- 
  allresight_raw%>%
  # full_join(rs17)%>%
  mutate(lat=as.numeric(lat), Bandnumb=as.numeric(bandnumb))%>%
  dplyr::select(Bandnumb,season,colony, orig_col,lat, lon)%>%
  filter(!lat==0, !lon==0)%>%
  group_by(Bandnumb,season)%>%
  dplyr::select(Bandnumb,season,lat,lon)%>%
  # keep only one record per band per season
  dplyr::slice(1)

# replace positive lat with negative
allrs_latlon$lat[allrs_latlon$lat>0]=-allrs_latlon$lat[allrs_latlon$lat>0]
# replace lat>-70 with NA
allrs_latlon$lat[allrs_latlon$lat>-77.3|allrs_latlon$lat<=(-600)]=NA
allrs_latlon$lat[allrs_latlon$lat<=(-600)]=NA
# allrs_latlon$lat[allrs_latlon$lat>-70]=NA
allrs_latlon$lon[allrs_latlon$lon>300]=NA
plot(allrs_latlon$lat)

c_bqi_loc <- 
  inner_join(c_bqi,allrs_latlon, by=c("Bandnumb","season"))%>%
 #   arrange(Bandnumb))
  # group_by(Bandnumb)%>%
  # dplyr::slice(n())%>%
  # ungroup%>%
  filter(!lat<(-78.0),!lat==1,!lat>-77.3,lon>168.0,lon<169.9)

plot(c_bqi_loc$lon,c_bqi_loc$lat)


# select individuals that meet criteria for study
# filter to birds that bred at least once in last 4 years and bred at least 3 times overall and 
# not in GDR deploy list
gdr_bands <- read.csv("Z:/Informatics/S031/analyses/GDR/data/cr_gdr_bands.csv")

c_bqi_crit <- c_bqi_loc%>%
  filter(Season%in%c(2014:2017),Br_exp>2,!Result=="NB",!Bandnumb%in%gdr_bands$band)%>%
  group_by(Bandnumb)%>%
  arrange(Season)%>%
  slice(n())

# read in predicted productivity raster
c_pred_prod<-raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_predict_subcol.tif")

# convert raster to points
c_pred_pt <- st_as_sf(rasterToPoints(pred_prod, spatial=TRUE))%>%
  rename(pred_prod=croz_predict_subcol)
plot(pred_pt, cex=.2)
# reproject to same a bqi locations
pred_pt <- st_transform(pred_pt,crs="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

# convert bqi coords to spatial points data frame
bqi_sp <- bqi_crit%>%
  ungroup()%>%
  dplyr::select(Bandnumb,lat,lon,BQI_A)%>%
  st_as_sf(coords=c("lon","lat"), remove=FALSE)

st_crs(bqi_sp)<- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"

# use spatial join to join predicted productivity to bqi
bqi_prod <- st_join(bqi_sp,pred_pt["pred_prod"], 
                    join=st_nn, maxdist=5)%>%
  as.data.frame(.)%>%
  dplyr::select(-geometry)

ggplot(bqi_prod,aes(pred_prod,BQI_A))+
  geom_point()+
  xlab("Predicted subcolony quality")+
  ylab("BQI")+
  geom_smooth(method = "lm")

Hmisc::rcorr(bqi_prod$BQI_A,bqi_prod$pred_prod)


write.csv(bqi_prod, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_bqi_pred_subcol_loc.csv", row.names = FALSE)



# read in table with Crozier  bqi and nearest predicted prod
c_bqi_pred_prod <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_bqi_all_pred_prod_v5.csv")%>%
  filter(!GRID_CODE==0,Br_exp>2,Season%in%c(2014,2015,2016,2017),Orig_col=="CROZ",!Device==1,!Device=="GDR")%>%
  rename(hab_qual=GRID_CODE)%>%
  group_by(Bandnumb)%>%
  arrange(Season)%>%
  dplyr::slice(n())

c_bqi_pred_prod<-read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_bqi_pred_subcol_loc.csv")


c_bqi_quant=quantile(c_bqi_pred_prod$BQI_A, probs = seq(0, 1, 0.25),na.rm=TRUE)
# low_break=c_bqi_pred_prod[58,"BQI_A"]
# mid_break=c_bqi_pred_prod[115,"BQI_A"]

c_bqi_pred_prod<- c_bqi_pred_prod%>%
  mutate(bqi_cat=ifelse(BQI_A<c_bqi_quant[2],"l",ifelse(BQI_A<c_bqi_quant[4],"m","h")))


ggplot(c_bqi_pred_prod,aes(BQI_A))+
  geom_histogram(bins=60)

# Overall correlation between BQI and predicted breeding success (habitat quality)
Hmisc::rcorr(c_bqi_pred_prod$BQI_A, c_bqi_pred_prod$pred_prod)


ggplot(c_bqi_pred_prod,aes(hab_qual,BQI_A))+
  geom_point()+geom_smooth(method=lm)+
  xlab("habitat quality")

# Scatter plot colored by bqi category
c_bqi_pred_prod$bqi_cat<- factor(c_bqi_pred_prod$bqi_cat, levels=c("h","m","l"))
c_bqi_pred_prod%>%
  group_by(bqi_cat)%>%
  summarise(mean_hq=mean(hab_qual))


p1_cbqi <-ggplot(c_bqi_pred_prod,aes(pred_prod,BQI_A, color=bqi_cat))+
  geom_point(size=1.8)+
  geom_smooth(method=lm, aes(fill=bqi_cat))+
  xlab("Habitat quality")+
  ylab("Breeding quality index (BQI)")+
  # scale_colour_manual(values = c("Black", "lightgrey", "grey50"))
  scale_fill_brewer(palette="Paired",labels = c("High","Medium","Low"), aesthetics = c("colour", "fill"))+
  # scale_color_brewer(palette="Paired",labels = c("High","Medium","Low"))+
  # theme_bw()+ 
  guides(colour=guide_legend(title="Crozier/nBQI/ncategory"), fill=guide_legend(title="Crozier/nBQI/ncategory"))+
  theme_classic()+
  ggtitle(("A"))+
  theme(plot.margin = unit(c(1, 0, 2, 1),"lines"))
print(p1_cbqi)
  


```
Predict breeding success at Royds
```{r pred BS at royds}
# Predict breeding success at Cape Royds ####
library(raster)
r_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_area_rast.tif")
ext_r<-extent(r_area)
plot(r_area)
# 
# Need to change this to y n for model
r_skua50<-crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_skua50m_bin.tif"),ext_r)
plot(r_skua50)

r_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_pa_ratio_rast.tif"),ext_r)
plot(r_pa_ratio)

# r_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_aspect_corrected.tif"),ext_r)
r_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_aspect.tif"),ext_r)

plot(r_aspect)

# r_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_slope"),ext_r)
r_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_slope.tif"),ext_r)
plot(r_slope)

# r_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_mosaic_dem-tile-0_clip_v2.tif"),ext_r)+46
r_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_elev.tif"),ext_r)+46
plot(r_elev)

# r_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_windshelter300m.asc"),ext_r)
r_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_windshelt.tif"),ext_r)
plot(r_windshelt)

# r_flow <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_flow_acc_snow_v2.1.tif"),ext_r))
r_flow <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_flow_acc.tif"),ext_r))
plot(r_flow)

# c_flow[c_flow==-Inf]<-NA


royds_stack <- stack(r_area, r_skua50, r_pa_ratio,r_aspect,r_slope,r_elev,r_windshelt, r_flow)
names(royds_stack)<-c("area","skua50","pa_ratio","mean_aspect","mean_slope","adjust_mean_elev","mean_windshelt","flow_acc_log1p")

# Predict to all subcolonies at Crozier
k=4
r_base_pred <- gam(prod_anom~s(area, k=k) + s(pa_ratio, k=k)+s(adjust_mean_elev, k=k)+ s(mean_slope, k=k) +s(mean_aspect,k=k, bs="cc") +s(mean_windshelt,k=k)+s(flow_acc_log1p, k=k)+skua50, select=TRUE, data=filter(pred_dat,col=="royds"), method="ML")

r_pred_anom <- predict(royds_stack,r_base_pred, type="response")

plot(r_pred_anom, col=rev(rainbow(50, start = 0, end = 0.8, alpha = 1)),main="Predicted subcol quality")
hist(r_pred_anom)
mean(r_pred_anom@data@values, na.rm=TRUE)
sd(r_pred_anom@data@values, na.rm=TRUE)/sqrt(sum(!is.na(r_pred_anom@data@values)))
writeRaster(r_pred_anom, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_predict_subcol.tif", format="GTiff", overwrite=FALSE)

# calcuated mean BS for last 4 years
r_bs4 <- r_dat%>%
  dplyr::select(season,subcol,prod)%>%
  filter(season%in%c("1415","1516","1617","1718"))
mean(r_bs4$prod)+mean(r_pred_anom@data@values, na.rm=TRUE)

c_bs4 <- c_dat%>%
  dplyr::select(season,subcol,prod)%>%
  filter(season%in%c("1415","1516","1617","1718"))
mean(c_bs4$prod, na.rm=TRUE)+mean(c_pred_anom@data@values, na.rm=TRUE)


# read in Royds BQI location and predicted productivity data
r_bqi_pred_prod <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/royds_bqi_pred_prod_loc.csv")
p2_rbqi <- ggplot(r_bqi_pred_prod,aes(pred_prod,BQI_A))+
  geom_point(size=1.8, col="black")+
  geom_smooth(method=lm, color="black")+
  labs(x="Habitat quality", y="Breeding quality index (BQI)", title="B")+
  theme_classic()+
  theme(plot.margin = unit(c(2, 5, 1, 1),"lines"))

print(p2_rbqi)

grid.arrange(p1_cbqi,p2_rbqi)

# correlate Royds bqi to predicted habitat quality
Hmisc::rcorr(r_bqi_pred_prod$BQI_A,r_bqi_pred_prod$pred_prod)



```

Distribution of pa-ratio
```{r pa-ratio of all subcols}

c_subcol <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/croz_all_subcol_2014.txt")%>%
  mutate(r=sqrt(area/pi),pa_circ=2/r,resid=pa_ratio-pa_circ, col="croz")

r_subcol <- read.csv("Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/royds_all_subcol_2014.txt")%>%
  mutate(r=sqrt(area/pi),pa_circ=2/r,resid=pa_ratio-pa_circ, col="royds")

subcol<- c_subcol%>%
  full_join(r_subcol)%>%
  dplyr::select(col,perim, area, pa_ratio, r, pa_circ, resid)

ggplot(c_subcol,aes(area,resid))+
  geom_point()+
  geom_smooth(method="loess")

ggplot(subcol,aes(area, pa_ratio, col=col))+
  geom_point()+
  geom_line(aes(area,pa_circ))+
  ylim(0,4)+
  xlim(0,1000)+
  geom_smooth(method="loess", col="green")

all_dat%>%
  group_by(col, subcol)%>%
  dplyr::slice(1)%>%
ggplot(aes(area, col=col))+
  geom_histogram()

# pa-ratio of study subcolonies

# data from with area and perimeter of circle
circ <- data.frame(area=c(1:1500))
circ$par=2/sqrt(circ$area/pi)
circ$perim = 2*pi*sqrt(circ$area/pi)

# plot
ggplot(all_dat)+
  geom_point(aes(area,perimeter, col=col))+
  geom_line(data=circ,aes(area,perim))+
  labs(x="Area",y="Perimeter")+
  theme_classic()+
  scale_colour_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))

# proportion of subcolonies <250m
subcol%>%
  mutate(smaller=ifelse(area<=250,1,0))%>%
  group_by(col, smaller)%>%
  summarise(n=n())


```
Plot spatial covariates
```{r Plot spatial covariates for both colonies}
# read in spatial layers for Crozier

library(raster)
c_area <- raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_area_rast.tif")
ext<-extent(c_area)
plot(c_area)

# Need to change this to y n for model
c_skua50<-crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_skua50mbin_rast.tif"),ext)
plot(c_skua50)

c_pa_ratio <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/covar_raster_stack/croz_all_subcol_2014_pa_ratio_rast.tif"),ext)
plot(c_pa_ratio)

c_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_aspect.tif"),ext)
plot(c_aspect)

c_slope <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_slope.tif"),ext)
plot(c_slope)

c_elev <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_elev.tif"),ext)+47
plot(c_elev)

c_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_subcol_windselt.tif"),ext)
plot(c_windshelt)

c_flow_all <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_flowacc_snow_v4.tif"),ext))
plot(c_flow)



