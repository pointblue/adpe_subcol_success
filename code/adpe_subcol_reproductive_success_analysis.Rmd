---
title: "Code for Schmidt et al. 2021 Scientific Reports 11:15380" 
author: "Annie Schmidt"
date: "Last edit 01-07-2022"
output:
  html_document:
    df_print: paged
  html_notebook: default
editor_options:
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message= FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_knit$set(root.dir = "Z:/Informatics/S031/analyses/aschmidt/subcol_var/data/final_data")


```

```{r load libraries and data, message=FALSE, warning=FALSE, results="hide"}

list.of.packages <- c("tidyverse", "mgcv","Hmisc", "stringr","gridExtra","nlme", "raster","rgdal","sf","nngeo","bbmle","circular","sp","ggsn","imager","rasterVis","RStoolbox")

# library(viridis)
# compare to existing packages
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
# install missing packages
if(length(new.packages)>0) {install.packages(new.packages)}
# load required packages
lapply(list.of.packages, library, quiet=TRUE,character.only = TRUE)


#All data required to run this analysis can be found here:
# http://deju-penguinscience.s3-us-east-2.amazonaws.com/AllData/index.html?prefix=AllData/Schmidt_etal_2021_SciRep/

# read in count data files with subcolony attributes (created by croz(royd)_subcol_ct_data_prep.R) ####

# Crozier
# v19 has windshelter calculated from windshelter_300m_pi_pi8_lcc169 and aspect calculated from means of cosin and sine of corrected aspect raster
c_ct_meas <- read_csv("croz_selected_meas_ct_all_v19.csv")

# Royds v12 has windshelter calculated from the South (not SE) and aspect calculated using trig functions 
r_ct_meas <- read_csv("royds_selected_meas_ct_all_v12.csv")


#Format data for modeling ####
# select columns for analysis
c_dat <- c_ct_meas%>%
  dplyr::select(-FID,-mean_elev, perim)%>%
  mutate(season=factor(season),subcol=factor(subcol), m=ifelse(area_name=="m","y","n"), skua50_yn=factor(ifelse(skua50==1,"y","n")),skua50=factor(skua50))%>%
# select only years 1415-1718  # remove s3 because it's an outlier
  filter(season%in%c("1415","1516","1617","1718"),!subcol=="s3",!prod=="NA"&!is.na(pa_ratio))%>%
  dplyr::rename(mean_windshelt=mean_windshelt300m, perimeter=perim)
  


# Format Royds data
r_dat <- r_ct_meas%>%
  dplyr::select(-FID,perimeter,-mean_elev)%>%
  mutate(season=factor(season),subcol=factor(subcol),col=factor(col),skua50_yn=factor(ifelse(skua50==1,"y","n")),skua50=factor(skua50),area_name=as.character(area_name))%>%
  # active count from 13 in 1617 looks off, exclude
  filter(!is.na(active_ct), !active_ct==0,!(subcol=="13"&season=="1617"))%>%
  dplyr::rename(mean_windshelt=mean_windshelt300m)
  
# one slope value for Royds 1b seems off (unlikely it's a 50deg slope)
# setting slope or 1b to value for other pixel that overlaps (more reasonable) Pixel value	25.368334
r_dat[r_dat$subcol=="1b","mean_slope"]=25.3683
# crazy slope causes other variables to be off also, need to reset these also to next pixel
# Flow acc change to 0
r_dat[r_dat$subcol=="1b","flow_acc"]=0
r_dat[r_dat$subcol=="1b","flow_acc_log1p"]=log1p(0)
# aspect to 253.100
r_dat[r_dat$subcol=="1b","mean_aspect"]=253.100
r_dat[r_dat$subcol=="1b","mean_windshelt"]=0.1545


# Combine data
all_dat <- c_dat%>%
  full_join(r_dat)%>%
  mutate(subcol=as.factor(subcol), col=as.factor(col),skua50_yn=factor(skua50_yn), season=factor(season))

```            

Check for correlated covariates
```{r check covariate correlation}
# Check covariate correlation
# Define functions #### 
# correlation matrix of data
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- cor(x, y, use="complete.obs")
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * abs(r))
}

pairs(c_dat[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)
# Max abs corr for Croz=0.46
pairs(r_dat[,c("prod","area","pa_ratio","mean_slope","mean_aspect","adjust_mean_elev", "mean_windshelt","flow_acc_log1p")],lower.panel = panel.smooth, upper.panel = panel.cor)
# Max corr for Royds = -0.74 (wind and aspect)
# only two subcol at Royds have flow acc values >0. There are 4 counts at each


```
Plot Crozier and Royds productivity (chicks per pair, Figure 2)
```{r Croz and royds productivity (figure 2), fig.dim = c(8,6)}

#Define colors
col1="#006C84" 
col2="#B2DBD5" # arctic
col3="#5EA8A7" # lagoon

# Croz and Royds productivity together ####
# Read in historic royds counts
r_ct_all <- read_csv("royds_all_ct_clean_thru1718.csv")

cr_count_all <- c_ct_meas%>%
  full_join(r_ct_all)%>%
  dplyr::select(col,subcol,season,prod)%>%
  mutate(season=factor(season,labels=c("2002","2003","2004","2005","2006","2007","2008","2009","2010","2011","2012",
                                      "2013","2014","2015","2016","2017")))%>%
  filter(!is.na(prod))


# Plot time series together (Fig 2.) ####
ggplot(cr_count_all,aes(season,prod, fill=col, color=col,))+
  geom_boxplot(alpha = 0.7,position = position_dodge(preserve = "single"))+
  ylab("Breeding success (chicks/pair)")+
  xlab("Season")+
  # stat_summary(fun.y=mean, geom="point", 
  #              shape=19, size=3,show.legend = FALSE,position=position_dodge(width=0.7)) +
  scale_color_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  scale_x_discrete(breaks=c("2002","2004","2006","2008","2010","2012","2014","2016"))+
  guides(fill=guide_legend(title="Colony"),color=guide_legend(title="Colony"))+
  theme_classic()+
  theme(axis.text=element_text(size=14),
        axis.title=element_text(size=16), legend.title = element_text(size = 18), legend.text = element_text(size=14))


# Some descriptive statistics #### 
# Coefficient of variation for Croz and Royds at different times ####
# Royds CV
r_cv_seas<-r_ct_all%>%
  group_by(season)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
# mean within year spatial variation
mean(r_cv_seas$cv, na.rm=TRUE)
plot(r_cv_seas$season,r_cv_seas$cv,type="o", ylim=c(0,1))


# overall cv of productivity (including all years and all subcol)
r_cv_ann<-r_ct_all%>%
  group_by(season)%>%
  summarise(ann_prod=mean(prod))
sd(r_cv_ann$ann_prod)/mean(r_cv_ann$ann_prod)


# Croz CV
c_cv_seas<-c_ct_meas%>%
  group_by(season)%>%
  summarise(mean=mean(prod,na.rm=TRUE),sd=sd(prod,na.rm=TRUE))%>%
  mutate(cv=sd/mean)
# mean within season cv
mean(c_cv_seas$cv, na.rm=TRUE)
par(mfrow=c(1,1))
plot(r_cv_seas$season,r_cv_seas$cv,type="o", ylim=c(0,1))
lines(c_cv_seas$season,c_cv_seas$cv,type="o", lwd=2)
mean(c_ct_meas$prod, na.rm=TRUE)

sd(c_cv_seas$mean)/mean(c_cv_seas$mean)
# overall cv of productivity (including all years and all subcol)
c_cv_ann<-c_ct_meas%>%
  group_by(season)%>%
  summarise(ann_prod=mean(prod,na.rm=TRUE))
sd(c_cv_ann$ann_prod)/mean(c_cv_ann$ann_prod)


# correlation between subcol area and count
cor_area_ct <-all_dat%>%
  # group_by(col)%>%
  summarise(r=cor(area,active_ct),p=cor.test(area,active_ct)$p.value)

# number of subcol with 4 counts
summ_cts_4 <- all_dat%>%
  group_by(col,subcol)%>%
  summarise(n=n())%>%
  group_by(col,n)%>%
  summarise(n4=n())

# number of subcolonies counted each year
summ_cts_yr <- all_dat%>%
  group_by(col,season)%>%
  summarise(n=n())

# Difference in means for whole time series
# t_cr_all <- t.test(c_ct_meas$prod, r_ct_all$prod)
# fit gls model to test for differences in means
# requires library()
nestinginfo <- groupedData(prod ~ col | subcol, data= cr_count_all)
# fit.compsym <- gls(prod ~ factor(col), data=nestinginfo, corr=corCompSymm(,form= ~ 1 | subcol))
# summary(fit.compsym)
fit.ar1 <- gls(prod ~ factor(col), data=nestinginfo, corr=corAR1(, form= ~ 1 | subcol))
summary(fit.ar1)
# anova(fit.compsym,fit.ar1)

# difference in means for 4 years of study
cr_4 <- cr_count_all%>%
  filter(season%in%c("2014","2015","2016","2017"))


# fit gls model to test for differences in means
nestinginfo4 <- groupedData(prod ~ col | subcol, data= cr_4)
# fit.compsym4 <- gls(prod ~ factor(col), data=nestinginfo4, corr=corCompSymm(,form= ~ 1 | subcol), method="ML")
# summary(fit.compsym4)
fit.ar14 <- gls(prod ~ factor(col), data=nestinginfo4, corr=corAR1(, form= ~ 1 | subcol), method="ML")
summary(fit.ar14)
# anova(fit.compsym4,fit.ar14)

# difference in mean between previous years and last 4
# Croz
c_4 <- cr_count_all%>%
  mutate(last4=factor(ifelse(season%in%c(2014,2015,2016,2017),1,0)))%>%
  filter(col=="croz")
c_l4info <- groupedData(prod ~ last4 | subcol, data= c_4)
c_fit.arl4 <- gls(prod ~ factor(last4), data=c_l4info, corr=corAR1(, form= ~ 1 | subcol), method="ML")
summary(c_fit.arl4)


filter(c_4,last4==0)%>%
  summarise(mean=mean(prod))

filter(c_4,last4==1)%>%
  summarise(mean=mean(prod))
# Royds
r_4 <- cr_count_all%>%
  mutate(last4=factor(ifelse(season%in%c(2014,2015,2016,2017),1,0)))%>%
  filter(col=="royds")
r_l4info <- groupedData(prod ~ last4 | subcol, data= r_4)
r_fit.arl4 <- gls(prod ~ factor(last4), data=r_l4info, corr=corAR1(, form= ~ 1 | subcol), method="ML")
summary(r_fit.arl4)

filter(r_4,last4==0)%>%
  summarise(mean=mean(prod))

filter(r_4,last4==1)%>%
  summarise(mean=mean(prod))


```

Crozier GAMs
```{r Crozier GAMs, fig.dim = c(8, 6)}
# Starting with model with all variables of interest

# remove annual mean so just modeling the spatial variability, not the annual variability
# note that this is the annual mean of the subcolonies
ann_prod_anom<-all_dat%>%
  group_by(col,season)%>%
  dplyr::summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(n()))%>%
  full_join(all_dat)%>%
  # converting aspect on -180 to 180 scale
  mutate(prod_anom = prod-mean_prod,mean_aspect=ifelse(mean_aspect>180,mean_aspect-360,mean_aspect))%>%
  mutate_at(vars(area,pa_ratio,mean_slope,mean_aspect,adjust_mean_elev,mean_windshelt,flow_acc,flow_acc_log,flow_acc_log1p),list(scale))


# Set k=6
ck=6
# Fit model with no interactions
c_base_anom <-gam(prod_anom~s(area, k=ck)+
                    s(pa_ratio, k=ck)+
                    s(mean_slope, k=ck)+
                    s(mean_aspect,k=ck, bs="cc") +
                    s(adjust_mean_elev,k=ck)+
                    s(flow_acc_log1p,k=ck)+ 
                    s(mean_windshelt,k=ck)+
                    skua50,
                  data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")


# check if basis dimensions sufficient
# par(mfrow=c(2,2))
# gam.check(c_base_anom) # most k-index values <1 but edf not close to k' so not changing anything
summary(c_base_anom)
# plot(c_base_anom,pages=1)
concurvity(c_base_anom) # everything <0.8 in the estimate row
round(concurvity(c_base_anom, full=FALSE)$estimate,2) # nothing over 0.49
# par(mfrow=c(2,2))
# gam.check(c_base_anom)


# Fit model with seasonal interactions
# No interactions between season and area and pa-ratio because they are not structural terrain characteristics
c_seasonx_anom <-gam(prod_anom~s(area, k=ck) + 
                       s(pa_ratio, k=ck)+
                       s(mean_slope, by=season, k=ck)+
                       s(mean_aspect,by=season,k=ck, bs="cc")+
                       s(adjust_mean_elev,by=season, k=ck)+
                       s(flow_acc_log1p,by=season,k=ck)+
                       s(mean_windshelt,by=season,k=ck)+
                       skua50*season, 
                     data=filter(ann_prod_anom,col=="croz"), select=TRUE, method="ML")
summary(c_seasonx_anom)
gam.check(c_seasonx_anom) # some p-values significant but edf not close to k' so leaving as is

par(mfrow=c(2,2))
plot.gam(c_seasonx_anom, shade=TRUE)


# check how compare
AICctab(c_base_anom,c_seasonx_anom,nobs=292, base=TRUE, weights=TRUE, logLik=TRUE)

```

Fit GAM for Royds
```{r Royds GAMs}

# set k for royds
rk=4
# create table to use in models
r_mdat <-filter(ann_prod_anom,col=="royds")

# flow at Royds has non-zero estimates at only 2 subcolonies (1c and 20a), doesn't seem like a good idea to include
# Fit model with no interactions

# base model is behaving oddly when both wind and aspect in the model
# windshelter and aspect are pretty highly correlated (-0.74)
# so running models with each independently

# model with wind but not aspect
r_base_wind <-
  gam(prod ~ s(area, k = rk) + 
      s(pa_ratio, k = rk) + 
      s(adjust_mean_elev, k =rk) + 
      s(mean_slope, k = rk) + 
      s(mean_windshelt, k = rk) + 
      skua50,
    data = r_mdat,
    select = TRUE,
    method = "ML"
  )
gam.check(r_base_wind)
summary(r_base_wind)
# plot.gam(r_base_wind, pages=1, shade=T, residuals=T)


# model with no windshelter but including aspect
r_base_aspect <-
  gam(
    prod_anom ~ s(area, k = rk) + 
      s(pa_ratio, k = rk) + 
      s(adjust_mean_elev, k =rk) + 
      s(mean_slope, k = rk) + 
      s(mean_aspect, k = rk, bs = "cc") + 
      skua50,
    data = r_mdat,
    select = TRUE,
    method = "ML"
  )
gam.check(r_base_aspect) # k may be too low but don't want to increase because will likely overfit
concurvity(r_base_aspect) # several estimates >0.8, pa-ratio and slope
round(concurvity(r_base_aspect, full=FALSE)$estimate,2) # pa ratio highest, highest concurvity with area and elevation. not much variability in elevation so could remove. Highest concurvity is 0.58 so think I could justify that that is OK
summary(r_base_aspect)
plot.gam(r_base_aspect, pages=1, shade=T, residuals=T)



# model with year interaction
# No interaction with season for area and pa-ratio because they are not terrain variables
r_seasonx<-  gam(prod_anom~s(area,k=rk) + 
                   s(pa_ratio,k=rk)+ 
                   s(adjust_mean_elev,by=season, k=rk)+
                   s(mean_slope,by=season,k=rk)+
                   s(mean_aspect,k=rk, bs="cc", by=season)+
                   skua50*season, data=r_mdat, select=TRUE, method="ML")
gam.check(r_seasonx)
summary(r_seasonx)
# plot.gam(r_seasonx, pages=1)

AICctab(r_base_wind, r_base_aspect,r_seasonx,nobs=86, base=TRUE, weights=TRUE, logLik=TRUE)

```

Estimate variable importance
```{r estimate variable importance}

cb<-c_base_anom # model for comparison

# Fit model with pa ratio removed and smooths for all other variables supplied from base model
# Area and wind already dropped

#### Note: order of variables must match base model!

# area removed
cb_area <- update(cb,.~.-s(area, k=ck),sp=cb$sp[-c(1,2)])
# summary(cb0)
#pa ratio removed
cb_pa <-update(cb,.~.-s(pa_ratio, k=ck),sp=cb$sp[-c(3,4)])
# summary(cb1)
# plot(cb1,pages=1)
# slope removed
cb_slope <- update(cb, .~.-s(mean_slope,k=ck),sp=cb$sp[-c(5,6)])
# summary(cb2)
# plot(cb2,pages=1)

# Aspect removed
cb_aspect <-update(cb,.~.-s(mean_aspect, k=ck, bs="cc"),sp=cb$sp[-c(7)])
# summary(cb3)
# plot(cb3, pages=1)

# elevation removed
cb_elev <-update(cb,.~.-s(adjust_mean_elev,k=ck),sp=cb$sp[-c(8,9)])
# summary(cb4)
# plot(cb2, pages=1)

# flow accumulation removed
cb_flow <- update(cb,.~.-s(flow_acc_log1p,k=ck),sp=cb$sp[-c(10,11)])
# summary(cb5)a
# plot(cb5,pages=1)

# windshelter removed
cb_wind <- update(cb,.~.-s(mean_windshelt,k=ck),sp=cb$sp[-c(12,13)])
# summary(cb6)
#Skua removed
cb_skua <- update(cb,.~.-skua50,sp=cb$sp)



# Royds
rb=r_base_aspect
# plot(rb,pages=1)

# area already dropped
#pa ratio removed
rb_pa <-update(rb,.~.-s(pa_ratio, k=rk),sp=rb$sp[-c(3,4)])
# summary(rb1)
# plot(rb1,pages=1)
# elevation removed
rb_elev <-update(rb,.~.-s(adjust_mean_elev, k=rk),sp=rb$sp[-c(5,6)])
# summary(rb2)
# plot(rb2, pages=1)
# slope removed
rb_slope <- update(rb, .~.-s(mean_slope,k=rk),sp=rb$sp[-c(7,8)])
# summary(rb3)
# plot(rb3,pages=1)
# Aspect already dropped but can confirm
rb_aspect <- update(rb, .~.-s(mean_aspect,k=rk, bs="cc"),sp=rb$sp[-c(9)])
# summary(rb4)
# plot(rb4,pages=1)
# flow accumulation removed
# rb4 <- update(rb,.~.-s(flow_acc_log1p,k=rk),sp=rb$sp[-c(10,11)])
# summary(rb4)
# plot(rb4,pages=1)
#Skua removed
rb_skua <- update(rb,.~.-skua50,sp=rb$sp)
# area removed
rb_area <- update(rb,.~.-s(area,k=rk),sp=rb$sp[-c(1,2)])
# summary(rb6)



# Make table of percent change in R2
# Variable list
term=c("Top","Area","Perim-area_ratio","Aspect","Slope","flow_acc","Wind_shelter","Elevation","skua")
rb_r2 <- round(c(summary(rb)$r.sq,summary(rb_area)$r.sq,summary(rb_pa)$r.sq,NA,summary(rb_slope)$r.sq,NA,NA,summary(rb_elev)$r.sq,summary(rb_skua)$r.sq),4)
cb_r2 <- round(c(summary(cb)$r.sq,NA,summary(cb_pa)$r.sq,summary(cb_aspect)$r.sq,summary(cb_slope)$r.sq,NA,summary(cb_wind)$r.sq,summary(cb_elev)$r.sq,summary(cb_skua)$r.sq),4)

r2_tab <- data.frame(term,cb_r2,rb_r2)%>%
  # calculate difference between top model and reduced model, and percent change
  mutate(c_dt_r2=round(first(cb_r2)-cb_r2,3),
         c_perc_r2=round(c_dt_r2*100/first(cb_r2),2),
         r_dt_r2=round(first(rb_r2)-rb_r2,3),
         r_perc_r2=round(r_dt_r2*100/first(rb_r2),2))%>%
  # round down r2
  mutate(cb_r2=round(cb_r2,2),rb_r2=round(rb_r2,2))%>%
  dplyr::select(term,cb_r2,c_dt_r2,c_perc_r2,rb_r2,r_dt_r2,r_perc_r2)


 
# write.csv(r2_tab, "delta_r2_tab.csv",row.names = FALSE)



```

Model figures
```{r model figs}
 
croz_ann_prod <- filter(ann_prod_anom,col=="croz")%>%
  mutate(predict_base=predict(c_base_anom))

royds_ann_prod <- filter(ann_prod_anom,col=="royds")%>%
  mutate(predict_base=predict(r_base_aspect))# p_rb1=predict(rb1), p_rb2=predict(rb2),p_rb3=predict(rb3), p_rb4=predict(rb4),p_rb5=predict(rb5),p_rb6=predict(rb6))

ann_prod_pred<-croz_ann_prod%>%
  full_join(royds_ann_prod)

ggplot(ann_prod_pred,aes(prod_anom,predict_base, colour=col))+
  geom_point(aes(shape=col, color=col),size=2)+
  geom_smooth(method="lm",show.legend = FALSE,aes(fill=col),alpha=0.4)+
  geom_abline(slope=1, intercept=0)+
  xlab("Observed breeding success")+
  ylab("Predicted breeding success")+
  # scale_colour_manual(values=c("#FF3366","grey60"),name="Colony",labels = c("Crozier","Royds"))+
  scale_colour_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))+
  scale_fill_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))+
  scale_shape(name="Colony",labels=c("Crozier","Royds"))+
  theme_classic()

# Model plots ####
# NOTE: Skua variable has to be numeric for raster prediction to work correctly
pred_dat<- all_dat%>%
  group_by(col,season)%>%
  dplyr::summarise(mean_prod=mean(prod, na.rm=TRUE),se=sd(prod, na.rm=TRUE)/sqrt(dplyr::n()))%>%
  full_join(all_dat)%>%
  mutate(prod_anom = prod-mean_prod, skua50=as.factor(skua50),mean_aspect=ifelse(mean_aspect>180,mean_aspect-360,mean_aspect))%>%
  ungroup()


c_base_pred <- gam(prod_anom~s(area, k=ck) + s(pa_ratio, k=ck)+s(adjust_mean_elev, k=ck)+ s(mean_slope, k=ck) +s(mean_aspect,k=ck, bs="cc") +s(mean_windshelt,k=ck)+s(flow_acc_log1p, k=ck)+skua50, select=TRUE, data=filter(pred_dat,col=="croz"), method="ML")

rk=4
# r_base_aspect <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+s(mean_slope,k=rk) +s(mean_aspect,k=rk, bs="cc")+skua50, data=r_mdat, select=TRUE, method="ML")
r_base_pred <- gam(prod_anom~s(area, k=rk) + s(pa_ratio, k=rk)+s(adjust_mean_elev, k=rk)+ s(mean_slope, k=rk) +s(mean_aspect,k=rk, bs="cc")+skua50, select=TRUE, data=filter(pred_dat,col=="royds"), method="ML")


```

Modeled relationships (Figure 4)
```{r Fig 4 (model smooths), fig.dim = c(8, 6)}
# Need to do them one at a time to modify labels


# Making a new function to do this
# need to predict each partial smooth and then plot
plot.smooths <- function(x, data, model, ylim=NULL, xlim=NULL,xlab=NULL,ylab="Effect on \n breeding success",col_x, add){
  par(bty="l")
#create a sequence of new data for variable of interest
new_dat <- seq(min(data[,x]),max(data[,x]),length=nrow(data))
# predict partial smooth
data[,x] <- new_dat
# predict with new data
pred <- predict(model,type="terms",newdata=data,se.fit=TRUE)
fit<-data.frame(pred$fit)
fit.up95<-fit-1.96*pred$se.fit
fit.low95<-fit+1.96*pred$se.fit
s.var <- paste("s.",x,".",sep="")
plot_dat <- data.frame(x=data[,x],fit_var=fit[,s.var])
# plot smooth but leave blank for now so that we can add the line on top of the polygon
if(add==FALSE){
plot(plot_dat[,x],plot_dat[,"fit_var"],ylim=ylim,xlim=xlim,add=add, xlab=xlab,ylab=ylab, type="n",cex.lab=1.6)
  polygon(c(new_dat, rev(new_dat)), 
        c(fit.low95[,s.var],rev(fit.up95[,s.var])), col=alpha(col_x,0.7),border=NA)
# add predicted line
lines(plot_dat[,x],plot_dat[,"fit_var"],  lwd=1, col=col_x)
} else {
# For the confidence grey polygon
polygon(c(new_dat, rev(new_dat)), 
        c(fit.low95[,s.var],rev(fit.up95[,s.var])), col=alpha(col_x,0.7),border=NA)
# add predicted line
lines(plot_dat[,x],plot_dat[,"fit_var"],  lwd=1, col=col_x)
}
}


# Croz and Royds on same panel
par(mfrow=c(3,3),mar=c(4,6,3,1),mgp=c(2.1,0.4,0), las=1, tck=-0.02)
ylim=c(-.5,0.45)

# Area ##
# Croz
xlim <- c(min(pred_dat[pred_dat$col=="croz","area"],pred_dat[pred_dat$col=="royds","area"]),max(pred_dat[pred_dat$col=="croz","area"],pred_dat[pred_dat$col=="royds","area"]))
plot.smooths(x="area",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Area",col_x=col1)
plot.smooths(x="area",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab=expression(Area~(m^2)),col_x=col2)


# PA ratio
var="pa_ratio"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="pa_ratio",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Perim-Area ratio",col_x=col1)
plot.smooths(x="pa_ratio",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Perim/Area ratio",col_x=col2)


# Aspect
var="mean_aspect"
xlim=c(-150,150)
plot.smooths(x="mean_aspect",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Aspect (°)",col_x=col1)
plot.smooths(x="mean_aspect",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlim=xlim,xlab="Aspect",col_x=col2)

# Slope
var="mean_slope"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="mean_slope",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Slope (°)",col_x=col1)
plot.smooths(x="mean_slope",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Slope",col_x=col2)

# Flow accumulation
var="flow_acc_log1p"
xlim <- c(min(pred_dat[,var]),max(pred_dat[,var]))
plot.smooths(x="flow_acc_log1p",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Flow accumulation (log)",col_x=col1)
# plot.smooths(x="flow_acc_log1p",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlab="Flow accumulation",col_x=col2)

# Wind shelter
var="mean_windshelt"
# xlim <- c(min(pred_dat[,var]),max(pred_dat[,var]))
xlim=c(0.12,0.5)
plot.smooths(x="mean_windshelt",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Wind shelter Index",col_x=col1)
# plot.smooths(x="mean_windshelt",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,xlim=xlim,xlab="Wind shelter",col_x=col2)

# Elevation
var="adjust_mean_elev"
xlim <- c(min(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]),max(pred_dat[pred_dat$col=="croz",var],pred_dat[pred_dat$col=="royds",var]))
plot.smooths(x="adjust_mean_elev",data=pred_dat[pred_dat$col=="croz",],model=c_base_pred,add=FALSE,ylim=ylim,xlim=xlim,xlab="Elevation (m)",col_x=col1)
plot.smooths(x="adjust_mean_elev",data=pred_dat[pred_dat$col=="royds",],model=r_base_pred,add=TRUE,ylim=ylim,col_x=col2)


# Skua
var="skua50"
# doing this one from scratch
c_skua0 <- c_base_pred$coefficients[1]
c_skua1<-c_skua0+c_base_pred$coefficients[2]
c_skua0_se <- summary(c_base_pred)$se[1]
c_skua1_se <- summary(c_base_pred)$se[2]

r_skua0 <- r_base_pred$coefficients[1]
r_skua1<-r_skua0+r_base_pred$coefficients[2]
r_skua0_se <- summary(r_base_pred)$se[1]
r_skua1_se <- summary(r_base_pred)$se[2]

cr_skua <- data.frame(col=c("croz","croz", "royds","royds"),
                      skua50=factor(c(0,1,0,1)),
                      coef=c(c_skua0, c_skua1, r_skua0, r_skua1),
                      ci=c(1.96*c_skua0_se, 1.96*c_skua1_se,1.96*r_skua0_se,1.96*r_skua1_se))

skua_mod<-ggplot(cr_skua,aes(skua50,coef,col=col))+
  geom_point(size=3,position=position_dodge(width=0.2))+
  geom_errorbar(aes(ymin=coef-ci,ymax=coef+ci),width=0.05, size=0.5,position=position_dodge(width=0.2))+
  theme_classic()+
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title=element_text(size=13),
        axis.text=element_text(size=8.5),
        plot.margin = margin(17,10,0,15, "pt"),
        axis.title.x=element_text(margin = margin(t = 8, r = 0, b = 0, l = 0)))+
  scale_y_continuous(breaks=c(-0.4,-0.2,0,0.2,0.4), limits=ylim)+
  ylab("Effect on\n breeding success")+
  xlab("Skua within 50m")+
  scale_colour_manual(values=c(col1,col2),name="Colony",labels = c("Crozier","Royds"))


plot.new()
vp <- grid::viewport(height = unit(0.31,"npc"), width=unit(0.34, "npc"), 
              just = c("center","bottom"),
              y = 0.005, x = 0.5,layout.pos.row = 3,layout.pos.col = 2)
print(skua_mod, vp = vp)


```

Predict Breeding success spatially
```{r predict breeding success spatially at croz}
# read in rasters to use for prediction
library(raster)

# format data for spatial prediction
k=6
# NOTE: Skua variable has to be numeric for raster prediction to work correctly
c_pred_dat <- filter(pred_dat,col=="croz")%>%
  mutate(skua50=as.numeric(skua50))
# update base model with non-normalized data for prediction
c_base_pred <- update(c_base_anom,data=c_pred_dat)

# c_season_pred <- gam(prod_anom~s(area, by=season, k=ck) + s(pa_ratio, by=season, k=ck)+s(mean_slope, by=season, k=ck)+s(mean_aspect,by=season,k=ck, bs="cc")+s(adjust_mean_elev,by=season, k=ck)+  +s(flow_acc_log1p,by=season,k=ck)+s(mean_windshelt,by=season,k=ck)+skua50*season, data=c_pred_dat, select=TRUE, method="ML")

# plot(c_base_pred, pages=1)
summary(c_base_pred)
# c_season_pred_val<- predict(c_season_pred)
c_base_pred_val <- predict(c_base_anom)
plot(croz_ann_prod$prod_anom,c_base_pred_val)
# correlation between observed and predicted
# rcorr(croz_ann_prod$prod_anom,c_season_pred_val)
rcorr(croz_ann_prod$prod_anom,c_base_pred_val)

# Load in raster data sets
# Need all variables even though some get dropped
library(raster)
c_area <- raster("croz_all_subcol_2014_area_rast.tif")
ext<-extent(c_area)
# plot(c_area)
# 
# Need to change this to y n for model
c_skua50<-crop(raster("croz_all_subcol_2014_skua50mbin_rast.tif"),ext)
# plot(c_skua50)

c_pa_ratio <- crop(raster("croz_all_subcol_2014_pa_ratio_rast.tif"),ext)
# plot(c_pa_ratio)

c_aspect <- crop(raster("croz_subcol_mean_aspect_trig180.tif"),ext)
# plot(c_aspect)

c_slope <- crop(raster("croz_subcol_slope.tif"),ext)
# plot(c_slope)

c_elev <- crop(raster("croz_subcol_elev.tif"),ext)+47
# plot(c_elev)

c_windshelt <- crop(raster("croz_subcol_mean_wind.tif"),ext)
# plot(c_wind_resamp)

c_flow <-log1p(crop(raster("croz_subcol_flow_acc.tif"),ext))
# plot(c_flow)

c_flow[c_flow==-Inf]<-NA

croz_stack <- stack(c_area, c_skua50, c_pa_ratio,c_aspect, c_slope,c_elev,c_windshelt, c_flow)
names(croz_stack)<-c("area","skua50","pa_ratio","mean_aspect","mean_slope","adjust_mean_elev","mean_windshelt","flow_acc_log1p")

# Predict subcolony quality to all subcolonies at Crozier
c_pred_anom <- predict(croz_stack,c_base_pred, type="response")
summary(c_pred_anom)

plot(c_pred_anom, col=rev(rainbow(50, start = 0, end = 0.8, alpha = 1)),main="Predicted subcolony quality")

range(c_pred_anom@data@values, na.rm=TRUE)
mean(c_pred_anom@data@values, na.rm=TRUE)
sd(c_pred_anom@data@values, na.rm=TRUE)/sqrt(sum(!is.na(c_pred_anom@data@values)))
# writeRaster(c_pred_anom, "Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/rev2/croz_predict_subcol.tif", format="GTiff", overwrite=FALSE)#




```
Predict breeding success at Royds
```{r predict BS at royds}
# read in spatial subcolony layers
r_area <- raster("royds_subcol_area.tif")
ext_r<-extent(r_area)
# plot(r_area)

r_skua50<-crop(raster("royds_subcol_skua50m_bin.tif"),ext_r)
# plot(r_skua50)

r_pa_ratio <- crop(raster("royds_subcol_pa_ratio.tif"),ext_r)
# plot(r_pa_ratio)

r_slope <- crop(raster("royds_subcol_slope.tif"),ext_r)
# plot(r_slope)

r_elev <- crop(raster("royds_subcol_elev.tif"),ext_r)+46
# plot(r_elev)

royds_stack <- stack(r_area, r_skua50, r_pa_ratio,r_slope,r_elev)
names(royds_stack)<-c("area","skua50","pa_ratio","mean_slope","adjust_mean_elev")

# Predict to all subcolonies at Crozier
k=4
r_pred_dat <- filter(pred_dat,col=="royds")%>%
  mutate(skua50=as.numeric(skua50))
# update top model with non-normalized data for prediction
r_base_pred <- update(r_base_aspect,.~.-s(mean_aspect,k=rk, bs="cc"),sp=rb$sp[-c(9)], data=r_pred_dat) # remove aspect because it was selected out during model fitting
r_base_pred_val <- predict(r_base_pred)
# correlation between observed and predicted
rcorr(royds_ann_prod$prod_anom,r_base_pred_val)

# plot(r_base_pred,pages=1)
r_pred_anom <- predict(royds_stack,r_base_pred, type="response")

plot(r_pred_anom, col=rev(rainbow(50, start = 0, end = 0.8, alpha = 1)),main="Predicted subcol quality")
range(r_pred_anom@data@values,na.rm=TRUE)
mean(r_pred_anom@data@values, na.rm=TRUE)
sd(r_pred_anom@data@values, na.rm=TRUE)/sqrt(sum(!is.na(r_pred_anom@data@values)))
# writeRaster(r_pred_anom, "royds_predict_subcol.tif", format="GTiff", overwrite=FALSE)

```


Crozier Covariate maps (Figure 5) 
```{r Crozier Covariate map (fig 5), fig.dim = c(8, 11)}
# Read in and format Crozier data####
# crozier boundary
croz_bound <- readOGR("croz_outer_bound.shp")

proj <-"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
croz_bound_t <- spTransform(croz_bound,proj)
c_ext <- extent(croz_bound_t)+0.0002

# aspect
c_aspect <- raster("croz_aspect_corrected180.tif")
c_aspect_t <- crop(projectRaster(c_aspect, crs=proj),c_ext)
c_aspect_spdf <- as(c_aspect_t, "SpatialPixelsDataFrame")
c_aspect_df <- as.data.frame(c_aspect_spdf)%>%
  rename(value=croz_aspect_corrected180)%>%
  mutate(value=ifelse(value<(-180),NA,value))

# slope
c_slope <- raster("croz_slope.tif")
c_slope_t <- crop(projectRaster(c_slope, crs=proj),c_ext)
c_slope_df <- as.data.frame(as(c_slope_t, "SpatialPixelsDataFrame"))%>%
  rename(value=croz_slope)%>%
  mutate(value=ifelse(value<0,NA,value))

# elevation
c_elev <- raster("crozier_dem.tif")+47 # add static shift of 47m to bring to zero for this latitude
c_elev_t <- crop(projectRaster(c_elev, crs=proj),c_ext)
c_elev_df <- as.data.frame(as(c_elev_t, "SpatialPixelsDataFrame"))%>%
  rename(value=crozier_dem)%>%
  mutate(value=ifelse(value<0,NA,value))

# flow accumulation
c_flow <- raster("croz_flowacc_snow_v2.tif")
c_flow_t <- crop(projectRaster(c_flow, crs=proj),c_ext)
c_flow_df <- as.data.frame(as(c_flow_t, "SpatialPixelsDataFrame"))%>%
  rename(value=croz_flowacc_snow_v2)%>%
  mutate(value=ifelse(value<0,NA,value),value=log1p(value))

# Wind shelter
c_wind <- raster("croz_windshelter300m_pi_pi8_lcc169.asc")
c_wind_t <- crop(projectRaster(c_wind, crs=proj),c_ext)
c_wind_df <- as.data.frame(as(c_wind_t, "SpatialPixelsDataFrame"))%>%
  rename(value=croz_windshelter300m_pi_pi8_lcc169)%>%
  mutate(value=ifelse(value<0,NA,value))

# Skua
c_skua <-raster("skua50m_dist_rast_bin.tif")
c_skua_ext <- c_ext
c_skua_t <- crop(projectRaster(c_skua, crs=proj),c_skua_ext)
c_skua_df <- as.data.frame(as(c_skua_t, "SpatialPixelsDataFrame"))%>%
  rename(value= skua50m_dist_rast_bin)%>%
  mutate(value=ifelse(is.na(value),0,value))



# make covariate plots ####
## colors 
col.p <- c("#006C84","#5EA8A7","#B2DBD5","white")


p.c_aspect<- ggplot() +  
  geom_raster(data=c_aspect_df, aes(x=x, y=y, fill=value), alpha=0.8)+
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
  fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(-180,180), "Aspect (°)") +
  theme(legend.position=c("right")) +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c("right", "top"),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.c_aspect)


p.c_slope<- ggplot() +  
  geom_raster(data=c_slope_df, aes(x=x, y=y, fill=value), alpha=0.8)+
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,30), "Slope (°)") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.c_slope)


p.c_elev<- ggplot() +  
  geom_raster(data=c_elev_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,225), "Elevation (m)") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"), axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.elev)


p.c_flow<- ggplot() +  
  geom_raster(data=c_flow_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,12), "Flow (log)") +
  theme(legend.position="right") +
  # theme(legend.key.width=unit(1, "cm"))+
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.flow)

p.c_wind<- ggplot() +  
  geom_raster(data=c_wind_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,0.75),"Wind shelt.\nIndex") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.wind)


p.c_skua<- ggplot() +  
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1)+
  geom_tile(data=c_skua_df, aes(x=x, y=y, fill=value))+
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="", fill="Skua nests")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.c_skua)

# croz Predicted subcol quality ###
# satellite image (proprietaty, copywrite owned by MAXAR Technologies, need permission to use)
# croz_WV3 <- stack("WV03_2014.tif")
# wv_ext <- extent(c_elev)
# croz_WV3_c <- crop(croz_WV3,crs=proj,wv_ext)
# croz_WV3_t <- crop(projectRaster(croz_WV3_c,crs=proj),c_ext)

# Predicted subcol quality raster
c_subcol_qual <- raster("croz_predict_subcol.tif")
c_subcol_t <- crop(projectRaster(c_subcol_qual, crs=proj),c_ext)
c_subcol_df <- as.data.frame(as(c_subcol_t, "SpatialPixelsDataFrame"))%>%
  rename(value= croz_predict_subcol)

# Skua nests
c_skua_nest<- read.csv("croz_skua_nests_1617.txt")%>%
  filter(lat<(-77.448))

# Turqoise to orange color scale
col.subcol <- c("#006C84","#B2DBD5","#e6ceb5","#ff8324","#f73c2f")

p.c_subcol<-  ggplot() +
  # ggRGB(croz_WV3_t,r=1,g=2,b=3,ggLayer=TRUE, maxpixels = 5e6)+
  geom_tile(data=c_skua_df, aes(x=x, y=y, fill=value), fill="white",alpha=0.3)+
  geom_tile(data=c_subcol_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=croz_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1)+
  scale_fill_gradientn(colors=col.subcol,limits =c(-0.11,0.15),"Subcolony\n quality")+
  geom_point(data=c_skua_nest,aes(x=lon,y=lat, color="#ffdd00"), size=3)+
  scale_color_identity(name = "Skua nests",labels="",guide="legend")+
  labs(x="Longitude",y="Latitude")+
  theme(legend.key.size = unit(1, "cm"),
    legend.position = c(0.93, 0.97),
    legend.justification = c(1, 1),
    legend.background = element_rect(fill = "grey50"),
    legend.text = element_text(colour="white"),
    legend.title = element_text(colour="white"),
    # legend.box.background = element_rect(fill="grey50"),
    legend.key=element_rect(fill="grey"),
    axis.title=element_text(size=14),
    axis.text=element_text(size=12))+
    scale_x_continuous(expand=c(0.0003,0.0005))+
    scale_y_continuous(expand=c(0.0001,0.0001))


# plot(p.c_subcol)


### put everything together

grid.arrange(p.c_aspect,p.c_slope,p.c_elev,p.c_flow,p.c_wind,p.c_subcol,
             ncol = 3, nrow = 4, 
             layout_matrix = rbind(c(1,2,3), c(4,6,6),c(5,6,6)))
```

Royds Covariate map (Figure 6)
```{r Royds covariate map (Figure 6),fig.dim = c(8, 11)}
# Read in and format Royds data ####
# Royds boundary
royds_bound <-rgdal::readOGR("royds_outer_bound_rev2.shp")
# set projection
proj <-"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
royds_bound_t <- spTransform(royds_bound,proj)
# save extent to use for other layers
r_ext <- extent(royds_bound_t)+0.001


# aspect
r_aspect <- raster("royds_aspect_corrected180.tif")
r_aspect_t <- crop(projectRaster(r_aspect, crs=proj),r_ext)
r_aspect_spdf <- as(r_aspect_t, "SpatialPixelsDataFrame")
r_aspect_df <- as.data.frame(r_aspect_spdf)%>%
  rename(value=royds_aspect_corrected180)%>%
  mutate(value=ifelse(value<(-180),NA,value))

# slope
r_slope <- raster("royds_slope.tif")
r_slope_t <- crop(projectRaster(r_slope, crs=proj),r_ext)
r_slope_df <- as.data.frame(as(r_slope_t, "SpatialPixelsDataFrame"))%>%
  rename(value=royds_slope)%>%
  mutate(value=ifelse(value<0,NA,value))

# elevation
r_elev <- raster("royds_mosaic_dem-tile-0_clip_v2.tif")+46 # add static offset of 46m
r_elev_t <- crop(projectRaster(r_elev, crs=proj),r_ext)
r_elev_df <- as.data.frame(as(r_elev_t, "SpatialPixelsDataFrame"))%>%
  rename(value=royds_mosaic_dem.tile.0_clip_v2)%>%
  mutate(value=ifelse(value<0,0,value))

# flow accumulation
r_flow <- raster("royds_flow_acc_snow_rev2.tif")
r_flow_t <- crop(projectRaster(r_flow, crs=proj),r_ext)
r_flow_df <- as.data.frame(as(r_flow_t, "SpatialPixelsDataFrame"))%>%
  rename(value=royds_flow_acc_snow_rev2)%>%
  mutate(value=ifelse(value<0,NA,value),value=log1p(value))

# Windshelter
r_wind <- raster("royds_windshelter300m_pi_pi8_lcc169_clip.tif")
r_wind_t <- crop(projectRaster(r_wind, crs=proj),r_ext)
r_wind_df <- as.data.frame(as(r_wind_t, "SpatialPixelsDataFrame"))%>%
  rename(value=royds_windshelter300m_pi_pi8_lcc169_clip)%>%
  mutate(value=ifelse(value<0,0,value))

# Skua
r_skua <-raster("royds_skua_50m_bin.tif")
r_skua_ext <- extent(r_skua)
r_skua_t <- crop(projectRaster(r_skua, crs=proj),r_ext)
r_skua_df <- as.data.frame(as(r_skua_t, "SpatialPixelsDataFrame"))%>%
  rename(value= royds_skua_50m_bin)


# Make royds covariate map ####

## colors 
col.p <- c("#006C84","#5EA8A7","#B2DBD5","white")

p.r_aspect<- ggplot() +  
  geom_raster(data=r_aspect_df, aes(x=x, y=y, fill=value), alpha=0.8)+
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1)+
  scale_fill_gradientn(colors=col.p,limits =c(-180,180), "Aspect (°)") +
  theme(legend.position=c("right")) +
  # theme(legend.key.width=unit(0.5, "cm"), legend.key.height = unit(2,"cm"))+
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c("right", "top"),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.r_aspect)


p.r_slope<- ggplot() +  
  geom_raster(data=r_slope_df, aes(x=x, y=y, fill=value), alpha=0.8)+
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,60), "Slope (°)") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.r_slope)


p.r_elev<- ggplot() +  
  geom_raster(data=r_elev_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,25), "Elevation (m)") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"), axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.r_elev)


p.r_flow<- ggplot() +  
  geom_raster(data=r_flow_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,7), "Flow (log)") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.r_flow)

p.r_wind<- ggplot() +  
  geom_raster(data=r_wind_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1) +
  scale_fill_gradientn(colors=col.p,limits =c(0,1.1),"Wind shelt.\nIndex") +
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.r_wind)


p.r_skua<- ggplot() +  
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1)+
  geom_tile(data=r_skua_df, aes(x=x, y=y, fill=value))+
  theme(legend.position="right") +
  theme(legend.key.width = unit(0.2, "cm"), legend.key.height = unit(0.35, "cm"))+
  labs(x="",y="", fill="Skua nests")+
  theme(legend.position = c(0.93, 0.91),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        axis.text=element_blank(),
        axis.ticks = element_blank())
# plot(p.r_skua)

# Royds Predicted subcol quality ###
# satellite image (proprietary, copyright owned by Maxar Technologies, obtain permission to use)
# royds_WV2 <- stack("w2_15.tif") # needs to be a stack to use ggRGB
# rwv_ext <- extent(r_aspect)
# royds_WV2_c <- crop(royds_WV2,crs=proj,rwv_ext)
# royds_WV2_t <- crop(projectRaster(royds_WV2_c,crs=proj),r_ext)


# Predicted subcol quality raster
r_subcol_qual <- raster("royds_predict_subcol.tif")
r_subcol_t <- crop(projectRaster(r_subcol_qual, crs=proj),r_ext)
r_subcol_df <- as.data.frame(as(r_subcol_t, "SpatialPixelsDataFrame"))%>%
  rename(value= royds_predict_subcol)

# Skua nests
r_skua_nest<- read.csv("royds_skua_nests_1617.csv")%>%
  filter(Lat!=0)

# Turqoise to orange color scale
col.subcol <- c("#006C84","#B2DBD5","#e6ceb5","#ff8324","#f73c2f")

p.r_subcol<-  ggplot() +
  # ggRGB(royds_WV2_t,r=1,g=2,b=3,ggLayer=TRUE, maxpixels = 5e6)+
  geom_tile(data=r_skua_df, aes(x=x, y=y, fill=value), fill="white",alpha=0.15)+
  geom_tile(data=r_subcol_df, aes(x=x, y=y, fill=value))+
  geom_polygon(data=royds_bound_t, aes(x=long, y=lat, group=group),
               fill=NA, col="white",size=1)+
  scale_fill_gradientn(colors=col.subcol,limits =c(-0.7,0.65),"Subcolony\n quality")+
  geom_point(data=r_skua_nest,aes(x=Lon,y=Lat, color="#ffdd00"), size=3)+
  scale_color_identity(name = "Skua nests",labels="",guide="legend")+
  labs(x="Longitude",y="Latitude")+
  theme(legend.key.size = unit(1, "cm"),
        legend.position = c(0.93, 0.97),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = "grey50"),
        legend.text = element_text(colour="white"),
        legend.title = element_text(colour="white"),
        legend.key=element_rect(fill="grey"),
        axis.title=element_text(size=14),
        axis.text=element_text(size=12))+
  scale_x_continuous(expand=c(0.0003,0.0005))+
  scale_y_continuous(expand=c(0.0001,0.0001))


# plot(p.r_subcol)


### put everything together
grid.arrange(p.r_aspect,p.r_slope,p.r_elev,p.r_flow,p.r_wind,p.r_subcol,
             ncol = 3, nrow = 4, 
             layout_matrix = rbind(c(1,2,3), c(4,6,6),c(5,6,6)))


```
Code to create figure comparing attributes of selected subcolonies to whole colony (Supplemental figure)
```{r Figure comparing attributes of sample subcols to whole colony (Supplemental Fig), echo=TRUE, eval=FALSE}

# this commented out chunk creates a table with attributes for every subolony ####
# it  takes a long to run so to speed up, just read in tables that were saved from this code (croz_all_subcol_attr.csv and royd_all_subcol_attr.csv)
# Make sure to  run chunk 10 and 11 prior to create croz_stack and royds_stack objects
# Read in subcol polygon layer
# croz_subcol <- readOGR("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/croz/layers/croz_all_subcol_boundaries_2014.shp")
# proj<-crs(c_area)
# # reproject to polar stereo to match subcol raster layers
# c_subcol_t <- spTransform(croz_subcol,proj)
# c_ext <- extent(c_subcol_t)
# # c_all_subcol_attr<- extract(croz_stack,c_subcol_t, fun=mean, na.rm=TRUE, df=TRUE) # this takes a long time
# 
# # read in Royds subcol boundaries
# royd_subcol <-readOGR("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/rev2/royds_subcol_2014.shp")
# 
# r_subcol_t <-spTransform(royd_subcol, proj)
# 
# # Royds stack is missing wind, flow and aspect so need to add those
# r_aspect <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/rev2/royds_subcol_aspect_090820.tif"),ext_r)
# r_windshelt <- crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/rev2/royds_subcol_windshelt_rev2_v3_polar.tif"),ext_r)
# r_flow <-log1p(crop(raster("Z:/Informatics/S031/analyses/aschmidt/subcol_var/GIS/royds/layers/royds_subcol_flow_acc.tif"),ext_r))
# 
# r_stack_v2 <- addLayer(royds_stack,r_aspect,r_windshelt,r_flow)
# names(r_stack_v2)[6:8] <-c("mean_aspect","mean_windshelt","flow_acc_log1p")
# r_all_subcol_attr<- extract(r_stack_v2,r_subcol_t, fun=mean, na.rm=TRUE, df=TRUE) 

# this takes a long time so if want to avoid re-doing, write results to files
# write subcol attribute table
# write.csv(c_all_subcol_attr, "croz_all_subcol_attr.csv", row.names = FALSE)
# write.csv(r_all_subcol_attr, "royd_all_subcol_attr.csv",row.names = FALSE) 
#_________________

# read in data files created above
c_all_subcol_attr <- read.csv("croz_all_subcol_attr.csv")%>%
  mutate(samp=0)
r_all_subcol_attr <- read.csv("royd_all_subcol_attr.csv")%>%
  mutate(samp=0)

# format sample subcolonies for merging
# c_dat has multiple rows persubcol so need to slice to just have each represented once
# add column for sample 1=in sample data set
c_samp_subcol_attr <- c_dat%>%
  dplyr::select(col:subcol,area_name:area,pa_ratio,mean_aspect:skua50,flow_acc_log1p)%>%
  mutate(samp=1,skua50=ifelse(as.numeric(skua50)==2,1,0))%>%
  group_by(subcol)%>%
  dplyr::slice(1)

# join and melt data for data vis
c_attr <- c_all_subcol_attr%>%
  mutate(ID=as.character(ID))%>%
  full_join(c_samp_subcol_attr,by=c("ID"="subcol","area", "skua50", "pa_ratio", "mean_aspect", "mean_slope", "adjust_mean_elev", "mean_windshelt", "flow_acc_log1p", "samp"))%>%
  mutate(col="croz")%>%
  dplyr::select(-season,-area_name)%>%
  gather(attr,value=measurement,-ID, -samp,-col)%>%
  mutate(measurement=as.numeric(measurement),attr=factor(attr, labels=c("Elevation (m)","Area (m2)","Flow accumulation (log)","Aspect (°)","Slope (°)","Wind shelter index","Perim-Area ratio", "Skua 50m")),attr=ordered(attr,levels=c("Area (m2)","Perim-Area ratio","Aspect (°)","Slope (°)","Flow accumulation (log)","Wind shelter index","Elevation (m)", "Skua 50m")),
         samp=factor(samp))%>%
  filter(!is.na(measurement))


#format royds sample subcols
r_samp_subcol_attr <- r_dat%>%
  dplyr::select(col,subcol,area,skua50,pa_ratio,mean_aspect:flow_acc_log1p,mean_slope,adjust_mean_elev,mean_windshelt)%>%
  mutate(samp=1,skua50=as.numeric(as.character(skua50)))%>%
  group_by(subcol)%>%
  dplyr::slice(1)

# join and melt for figure
r_attr <- r_all_subcol_attr%>%
  mutate(ID=as.character(ID))%>%
  full_join(r_samp_subcol_attr,by=c("ID"="subcol","area", "skua50", "pa_ratio", "mean_aspect", "mean_slope", "adjust_mean_elev", "mean_windshelt", "flow_acc_log1p", "samp"))%>%
  mutate(col="royds")%>%
  dplyr::select(-flow_acc_log)%>%
  gather(attr,value=measurement,-ID, -samp,-col)%>%
  mutate(measurement=as.numeric(measurement),attr=factor(attr, labels=c("Elevation (m)","Area (m2)","Flow accumulation (log)","Aspect (°)","Slope (°)","Wind shelter index","Perim-Area ratio", "Skua 50m")),attr=ordered(attr,levels=c("Area (m2)","Perim-Area ratio","Aspect (°)","Slope (°)","Flow accumulation (log)","Wind shelter index","Elevation (m)", "Skua 50m")),
         samp=factor(samp))%>%
  filter(!is.na(measurement))

# Figure
col1="#006C84" 
col2="#B2DBD5" # arctic

# Crozier figure
c_attr%>%
  group_by(ID,col,attr)%>%
  dplyr::slice(1)%>%
  ggplot(aes(x=measurement,fill=samp))+
  facet_wrap(~attr,scales="free",strip.position = "bottom")+
  geom_density(data=subset(c_attr,attr%in%c("Area (m2)","Perim-Area ratio","Aspect (°)","Slope (°)","Flow accumulation (log)","Wind shelter index","Elevation (m)")),alpha = 0.7, color="white")+
  geom_bar(data=subset(c_attr,attr=="Skua 50m"),bins=2,stat="bin",position=position_dodge(0.8),aes(y=..density..),color="white",alpha=0.7)+
  ylab("Density")+
  xlab("")+
  scale_fill_manual(values=c(col1,col2),labels = c("All","Sample"))+
  theme_classic()+
  theme(strip.placement = "outside",
        # strip.placement.y="outside",
        strip.background = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.border=element_blank(),axis.line= element_line(colour = "black"),panel.spacing = unit(1.5, "lines"),
        strip.text=element_text(size=11), axis.text=element_text(size=9),
        plot.margin=margin(t = 10, r = 2, b = 0, l = 0, unit = "pt"),
        legend.position="right")+
  guides(fill=guide_legend(title="Subcolonies"))+
  guides(fill=guide_legend(title="Subcolonies"),color=guide_legend(title="Subcolonies"))



# Royds figure
ggplot(r_attr,aes(x=measurement,fill=samp))+
  facet_wrap(~attr,scales="free",strip.position = "bottom")+
  geom_density(data=subset(r_attr,attr%in%c("Area (m2)","Perim-Area ratio","Aspect (°)","Slope (°)","Flow accumulation (log)","Wind shelter index","Elevation (m)")),alpha = 0.7, color="white")+
  geom_bar(data=subset(r_attr,attr=="Skua 50m"),bins=2,stat="bin",position=position_dodge(0.8),aes(y=..density..),color="white",alpha=0.7)+
  ylab("Density")+
  xlab("")+
  scale_fill_manual(values=c(col1,col2),labels = c("All","Sample"))+
  theme_classic()+
  theme(strip.placement = "outside",
        # strip.placement.y="outside",
        strip.background = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.border=element_blank(),axis.line= element_line(colour = "black"),panel.spacing = unit(1.5, "lines"),
        strip.text=element_text(size=11), axis.text=element_text(size=9),
        plot.margin=margin(t = 10, r = 2, b = 0, l = 0, unit = "pt"),
        legend.position="right")+
  guides(fill=guide_legend(title="Subcolonies"))+
  guides(fill=guide_legend(title="Subcolonies"),color=guide_legend(title="Subcolonies"))



# tests for differences between colonies
pair_dat <-c_attr%>%
  full_join(r_attr)%>%
  spread(attr,measurement)%>%
  rename(aspect = `Aspect (°)`)%>%
  mutate(aspect = ifelse(aspect > 180,aspect -360, aspect))%>%
  rename(`Aspect (°)`=aspect)%>%
  distinct()


# Most variables not normal so used Mann-Whitney U test
wilcox.test(pair_dat$`Elevation (m)`[pair_dat$col=="croz"],pair_dat$`Elevation (m)`[pair_dat$col=="royds"]) # 34020, p-value < 2.2e-16
wilcox.test(pair_dat$`Area (m2)`[pair_dat$col=="croz"],pair_dat$`Area (m2)`[pair_dat$col=="royds"]) # W = 22372, p-value = 0.0007813
wilcox.test(pair_dat$`Flow accumulation (log)`[pair_dat$col=="croz"],pair_dat$`Flow accumulation (log)`[pair_dat$col=="royds"])#W = 23626, p-value = 3.684e-06

# croz max area
max(pair_dat$`Area (m2)`[pair_dat$col=="croz"&pair_dat$samp==1])

# test difference in aspect
x<-as.circular(pair_dat$`Aspect (°)`[pair_dat$col=="croz"],units="degrees", rotation="clock")
y <-as.circular(pair_dat$`Aspect (°)`[pair_dat$col=="royds"],units="degrees",rotation="clock")
watson.two.test(x,y) #test statistic 2.04, critical values 0.187, p<0.001
median(pair_dat$`Aspect (°)`[pair_dat$col=="croz"]) # 56.5
median(pair_dat$`Aspect (°)`[pair_dat$col=="royds"]) # -58.4
#crozier mean aspect
mean.circular(x) #60.07
# royds mean aspect
mean.circular(y) #-54.9


wilcox.test(pair_dat$`Slope (°)`[pair_dat$col=="croz"],pair_dat$`Slope (°)`[pair_dat$col=="royds"]) # W = 22244, p-value = 0.001062
wilcox.test(pair_dat$`Wind shelter index`[pair_dat$col=="croz"],pair_dat$`Wind shelter index`[pair_dat$col=="royds"])#  W = 25560, p-value = 6.659e-09
wilcox.test(pair_dat$`Perim-Area ratio`[pair_dat$col=="croz"],pair_dat$`Perim-Area ratio`[pair_dat$col=="royds"])# W = 11775, p-value = 0.0001899
wilcox.test(pair_dat$`Skua 50m` [pair_dat$col=="croz"],pair_dat$`Skua 50m`[pair_dat$col=="royds"]) # W = 9694.5, p-value = 3.222e-11


# Test if proportion of subcol with skuas near is different
croz_skua<- sum(pair_dat$`Skua 50m`[pair_dat$col=="croz"])
n_croz<-length(pair_dat$`Skua 50m`[pair_dat$col=="croz"])
royds_skua <- sum(pair_dat$`Skua 50m`[pair_dat$col=="royds"])
n_royds <- length(pair_dat$`Skua 50m`[pair_dat$col=="royds"])


# data frame with proportions and CI
prop_skua <- data.frame(croz_skua,n_croz,prop_croz=croz_skua/n_croz,royds_skua,n_royds,prop_royds=royds_skua/n_royds)
# Proportion margin of error
#z*sqrt(p(1-p)/n)
prop_skua$croz_CI <- 1.96*sqrt((prop_skua$prop_croz*(1-prop_skua$prop_croz))/n_croz)
prop_skua$royds_CI <- 1.96*sqrt((prop_skua$prop_royds*(1-prop_skua$prop_royds))/n_royds)

# test if difference in proportion is significant
prop.test(x=c(croz_skua,royds_skua),n=c(n_croz,n_royds))

```

Figure of subcolony attribute distributions for Crozier and Royds (Figure 3)
```{r Figure 3, eval=FALSE, echo=TRUE}
# Figure with croz and royds together 
dat <- pair_dat%>%
  filter(`Area (m2)`<1500)%>%
  gather(attr,value=measurement,-ID, -samp,-col)%>%
  mutate(attr=ordered(attr,levels=c("Area (m2)","Perim-Area ratio","Aspect (°)","Slope (°)","Flow accumulation (log)","Wind shelter index","Elevation (m)", "Skua 50m")))


ggplot(dat,aes(x=measurement, fill=col,color=col))+
  facet_wrap(~attr,scales="free",strip.position = "bottom")+
  geom_density(data=subset(dat,attr%in%c("Area (m2)","Perim-Area ratio","Aspect (°)","Slope (°)","Flow accumulation (log)","Wind shelter index","Elevation (m)")),alpha = 0.7, color="white")+
  geom_bar(data=subset(dat,attr=="Skua 50m"),bins=2,stat="bin",position=position_dodge(0.8),aes(y=..density..),color="white",alpha=0.7)+
  ylab("Density")+
  xlab("")+
  scale_fill_manual(values=c(col1,col2),labels = c("Crozier","Royds"))+
  theme_classic()+
  theme(strip.placement = "outside",
        strip.background = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(), panel.border=element_blank(),axis.line= element_line(colour = "black"),panel.spacing = unit(1.5, "lines"),
        strip.text=element_text(size=11), axis.text=element_text(size=9),
        plot.margin=margin(t = 10, r = 2, b = 0, l = 0, unit = "pt"),
        legend.position="right")+
  guides(fill=guide_legend(title="Colony"))



```
